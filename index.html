<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encrypted P2P Chat & Call</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Base Chat Backgrounds & General Colors */
    body.light { background-color: #f0f0f0; color: #212121; } /* Changed text color to a darker shade */
    body.dark { background-color: #1a1a1a; color: #eee; }
    body.theme-3 { background-color: #e0f2f7; color: #212121; } /* Light blue */
    body.theme-4 { background-color: #f0fff4; color: #222; } /* Light green */

    /* Chat Box Backgrounds */
    body.light .chat-bg {
      background-color: #e5ddd5;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 800 800"><g fill="%23cbc5bd" fill-opacity="0.4"><path d="M0 0h800v800H0z"/><path d="M283.25 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zM0 283.25c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm583.25-100c55.25 0 100 44.75 100 100v100h-200V183.25c0-55.25 44.75-100 100-100zM0 516.75c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm283.25 100c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm266.5-100c55.25 0 100 44.75 100 100v100h-200V516.75c0-55.25 44.75-100 100-100z"/></g></svg>');
    }
    body.dark .chat-bg { background-color: #0d1418; }
    body.theme-3 .chat-bg { background-color: #bbdefb; } /* Lighter blue for chat background */
    body.theme-4 .chat-bg { background-color: #c8e6c9; } /* Lighter green for chat background */


    /* Header/Footer Backgrounds */
    body.light header, body.light footer { background-color: #f0f0f0; }
    body.dark header, body.dark footer { background-color: #1f2c34; }
    body.theme-3 header, body.theme-3 footer { background-color: #81d4fa; } /* Bright blue */
    body.theme-4 header, body.theme-4 footer { background-color: #a5d6a7; } /* Muted green */

    /* Header/Footer Text Colors */
    body.light header, body.light header h2, body.light header button { color: #212121; }
    body.dark header, body.dark header h2, body.dark header button { color: #ffffff; }
    body.theme-3 header, body.theme-3 header h2, body.theme-3 header button { color: #01579B; } /* Dark blue for theme-3 header text */
    body.theme-4 header, body.theme-4 header h2, body.theme-4 header button { color: #1B5E20; } /* Dark green for theme-4 header text */

    /* Input/Textarea Backgrounds */
    body.light input, body.light textarea { background-color: #fff; border-color: #ddd; color: #212121; } /* Changed text color to a darker shade */
    body.dark input, body.dark textarea { background-color: #2a3942; border-color: #555; color: #eee; }
    body.theme-3 input, body.theme-3 textarea { background-color: #e3f2fd; border-color: #90caf9; color: #212121; }
    body.theme-4 input, body.theme-4 textarea { background-color: #e8f5e9; border-color: #a5d6a7; color: #222; }
    
    /* Sent Bubbles */
    .sent-bubble { background-color: #dcf8c6; color: #212121; } /* Changed text color to a darker shade */
    .dark .sent-bubble { background-color: #056162; color: #eee; } /* Default dark green */
    .theme-3 .sent-bubble { background-color: #4fc3f7; color: #fff; } /* Blue for sent */
    .theme-4 .sent-bubble { background-color: #66bb6a; color: #fff; } /* Green for sent */

    /* Received Bubbles */
    .received-bubble { background-color: #ffffff; color: #212121; } /* Changed text color to a darker shade */
    .dark .received-bubble { background-color: #2a3942; color: #eee; } /* Default dark grey */
    .theme-3 .received-bubble { background-color: #e1f5fe; color: #212121; } /* Light blue for received */
    .theme-4 .received-bubble { background-color: #f1f8e9; color: #222; } /* Light yellow-green for received */


    /* Tail for Bubbles */
    .message-bubble:after {
        content: ''; position: absolute; top: 0; width: 0; height: 0; border: 10px solid transparent;
    }
    .sent-bubble:after { right: -10px; }
    .received-bubble:after { left: -10px; }

    /* Tail colors based on theme */
    .light .sent-bubble:after { border-left-color: #dcf8c6; }
    .dark .sent-bubble:after { border-left-color: #056162; }
    .theme-3 .sent-bubble:after { border-left-color: #4fc3f7; }
    .theme-4 .sent-bubble:after { border-left-color: #66bb6a; }

    .light .received-bubble:after { border-right-color: #ffffff; }
    .dark .received-bubble:after { border-right-color: #2a3942; }
    .theme-3 .received-bubble:after { border-right-color: #e1f5fe; }
    .theme-4 .received-bubble:after { border-right-color: #f1f8e9; }


    /* Scrollbar */
    #chatBox::-webkit-scrollbar { width: 6px; }
    #chatBox::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
    body.dark #chatBox::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }
  </style>
</head>
<body class="light">

  <div id="app" class="h-screen w-screen flex flex-col hidden">
    <header class="p-3 flex items-center justify-between shadow-sm z-10">
      <h2 class="text-lg font-medium">Encrypted P2P Chat</h2>
      <div class="flex items-center space-x-2">
          <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h1M3 12H2m8.006-7.5l-.574-.574m-9.454 9.454l-.574-.574M19 12a7 7 0 11-14 0 7 7 0 0114 0zm-9.146 5.146l.574.574m9.454-9.454l-.574-.574" />
              </svg>
          </button>
          <button onclick="initiateCall('audio')" class="px-3 py-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center space-x-2 text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" /></svg>
              <span>Audio Call</span>
          </button>
          <button onclick="initiateCall('video')" class="px-3 py-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center space-x-2 text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.55a1 1 0 011.45.89V16.1a1 1 0 01-1.45.9L15 14M5 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM19 10a2 2 0 11-4 0 2 2 0 014 0z"/></svg>
              <span>Video Call</span>
          </button>
      </div>
    </header>

    <main id="chatBox" class="flex-grow p-4 overflow-y-auto chat-bg"></main>

    <div id="progressContainer" class="px-4 pb-2 chat-bg flex items-center space-x-2" style="display: none;">
        <div class="flex-grow">
            <div class="text-sm text-gray-600 dark:text-gray-400 mb-1" id="progressLabel"></div>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
              <div id="progressBar" class="bg-green-500 h-2.5 rounded-full transition-all duration-150" style="width: 0%"></div>
            </div>
        </div>
        <button id="cancelFileBtn" onclick="cancelFileTransfer(true)" class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm hidden">Cancel</button>
    </div>

    <footer class="p-2 flex items-center space-x-2">
        <label class="flex items-center space-x-1 cursor-pointer p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600" title="Send as a view-once message or file">
            <input type="checkbox" id="viewOnce" class="form-checkbox h-4 w-4 text-green-600 bg-gray-100 dark:bg-gray-900 border-gray-300 dark:border-gray-600 rounded focus:ring-green-500">
            <span class="text-xs text-gray-500">View Once</span>
        </label>
        <input type="file" id="mediaInput" onchange="prepareFile(event)" class="hidden" />
        <label for="mediaInput" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>
        </label>
        <textarea id="message" placeholder="Type a message" class="flex-grow p-2 rounded-full border focus:outline-none focus:ring-2 focus:ring-green-500" rows="1" onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"></textarea>
        <button onclick="sendMessage()" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
        </button>
    </footer>
  </div>

  <div id="setup" class="min-h-screen bg-gray-100 dark:bg-gray-900 flex items-center justify-center p-4">
      <div class="max-w-xl w-full bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg space-y-4">
          <h2 class="text-2xl font-bold text-center text-gray-800 dark:text-gray-200">Setup Secure Connection</h2>
          <div><label class="font-bold text-gray-600 dark:text-gray-400">1. Enter a Shared Secret (Password)</label><input type="text" id="sharedKey" placeholder="Must match your peer's secret" oninput="checkStrength()" class="w-full mt-1 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded" /><div id="strengthMeter" class="text-sm mt-1"></div></div>
          <div class="grid md:grid-cols-2 gap-4">
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">2. Start & Share Your Signal</label><button onclick="startChat()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Start New Chat</button><textarea id="signalOut" placeholder="Your signal data appears here..." class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="copySignal()" class="w-full bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded">Copy Signal</button></div>
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">3. Paste Peer's Signal & Connect</label><textarea id="signalIn" placeholder="Paste peer's signal data here" class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="connect()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Connect</button></div>
          </div>
          <button onclick="newConnection()" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded mt-4">Start New Connection</button>
          <div id="log" class="text-center text-sm text-gray-500 dark:text-gray-400"></div>
      </div>
  </div>
  
  <div id="video-container" class="fixed inset-0 bg-black bg-opacity-90 hidden z-20 flex items-center justify-center p-4"><div class="relative w-full h-full flex items-center justify-center"><video id="remoteVideo" autoplay class="h-full w-auto max-w-full rounded-lg"></video><video id="localVideo" autoplay muted class="absolute bottom-6 right-6 w-1/4 max-w-xs rounded-lg border-2 border-white shadow-lg"></video></div><div id="call-controls" class="absolute bottom-10 flex items-center space-x-4"><button id="audioBtn" onclick="toggleAudio()" class="p-3 rounded-full bg-gray-700 hover:bg-gray-600 text-white">Mute</button><button id="videoBtn" onclick="toggleVideo()" class="p-3 rounded-full bg-gray-700 hover:bg-gray-600 text-white">Cam Off</button><button onclick="endCall(true)" class="p-3 rounded-full bg-red-600 hover:bg-red-500 text-white">End Call</button></div></div>

  <div id="incoming-call-notice" class="hidden fixed bottom-5 right-5 bg-white dark:bg-gray-800 shadow-2xl rounded-lg p-4 z-30 border dark:border-gray-600">
      <p id="incoming-call-text" class="text-gray-800 dark:text-gray-200"></p>
      <div class="mt-4 flex justify-end space-x-2">
          <button id="decline-call-btn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Decline</button>
          <button id="accept-call-btn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Accept</button>
      </div>
  </div>

  <div id="fullscreen-viewer" onclick="hideFullscreenImage()" class="hidden fixed inset-0 bg-black bg-opacity-80 z-40 flex items-center justify-center p-4 cursor-pointer">
      <img id="fullscreen-image" src="" class="max-w-full max-h-full">
      <button onclick="hideFullscreenImage()" class="absolute top-5 right-5 text-white text-4xl font-bold">&times;</button>
  </div>

  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script>
    let peer, aesKey, localStream;
    let receivingFile = {}, sendingFile = {};
    let viewOnceBlobs = {};
    let chatMessages = []; // Array to store message objects for localStorage
    const MAX_MESSAGES = 100; // Limit for messages to store in localStorage
    const CHUNK_SIZE = 64 * 1024;
    let currentCallType = null; // To track call type
    let fileReader = null; // Reference to FileReader for cancellation

    // Define the themes and their names
    const themes = ['light', 'dark', 'theme-3', 'theme-4'];
    let currentThemeIndex = 0;

    // --- UTILITY & SETUP ---
    function toggleTheme() {
        // Remove all existing theme classes
        document.body.classList.remove(...themes);

        // Move to the next theme
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        const newTheme = themes[currentThemeIndex];

        // Apply the new theme
        document.body.classList.add(newTheme);
        localStorage.setItem('theme', newTheme); // Save theme preference
    }

    function logToSetup(msg) { document.getElementById('log').textContent = msg; }
    async function deriveKey(password) { const enc = new TextEncoder();const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);return crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode("p2p-chat-salt"), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]); }
    function checkStrength() { const val = document.getElementById('sharedKey').value;const meter = document.getElementById('strengthMeter');if (val.length > 15 && /[A-Z]/.test(val) && /[0-9]/.test(val) && /[^A-Za-z0-9]/.test(val)) {meter.textContent = '🔒 Strong Password'; meter.className = 'text-sm mt-1 text-green-500';} else if (val.length > 8) {meter.textContent = '🟡 Medium Strength'; meter.className = 'text-sm mt-1 text-yellow-500';} else {meter.textContent = '🔓 Weak Password'; meter.className = 'text-sm mt-1 text-red-500';}}
    function startChat() { 
        if (!document.getElementById('sharedKey').value) { logToSetup('Please enter a shared secret first.'); return; } 
        initPeer(true); 
        logToSetup('Signal generated. Copy and send it to your peer.'); 
    }
    function connect() { 
        if (!document.getElementById('sharedKey').value) { logToSetup('Please enter a shared secret first.'); return; } 
        if (!document.getElementById('signalIn').value) { logToSetup('Please paste the peer\'s signal first.'); return; } 
        if (!peer) initPeer(false); 
        try { 
            peer.signal(JSON.parse(document.getElementById('signalIn').value)); 
        } catch { 
            logToSetup('⚠️ Invalid signal data'); 
        } 
    }
    function copySignal() { 
        const out = document.getElementById('signalOut');
        if (!out.value) { logToSetup('Generate a signal first!'); return; }
        navigator.clipboard.writeText(out.value).then(() => logToSetup('Signal copied to clipboard.'), () => logToSetup('Failed to copy signal.')); 
    }

    function newConnection() {
        localStorage.removeItem('sharedKey');
        localStorage.removeItem('localSignal');
        localStorage.removeItem('chatMessages'); // Clear chat history for new connection
        window.location.reload(); // Reload the page to reset everything
    }
    
    // --- UI & LOGGING ---
    function log(content, type = 'system', msgId = '') {
        const chatBox = document.getElementById('chatBox');
        const div = document.createElement('div');

        // Store message object for localStorage
        const messageObject = { content, type, id: msgId, timestamp: Date.now() };
        
        if (type === 'system') {
            div.className = 'text-center my-2';
            div.innerHTML = `<span class="bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs font-semibold px-2 py-1 rounded-full">${content}</span>`;
            // System messages are not saved in chat history for simplicity,
            // but you could add them if desired.
            if (msgId && !content.includes('Receiving file:') && !content.includes('Preparing to send:')) { // Only save system messages related to file transfer start for re-render
                // For simplicity, we don't re-render progress updates or call logs from history.
                // We save meta, but actual logging happens in real-time.
            }
        } else {
            const bubble = document.createElement('div');
            div.id = msgId; // Apply ID to the outer div

            bubble.className = 'message-bubble relative max-w-md md:max-w-lg px-3 py-2 rounded-lg shadow';

            if (type === 'sent') {
                div.className = 'flex justify-end mb-2';
                bubble.classList.add('sent-bubble');
            } else {
                div.className = 'flex justify-start mb-2';
                bubble.classList.add('received-bubble');
            }
            bubble.innerHTML = content;
            div.appendChild(bubble);

            // Add to chatMessages array only for 'sent' and 'received' messages
            // Don't save HTML for 'view-once' as it's dynamic
            if (type !== 'view-once-text' && !content.includes('View-Once Media')) {
                chatMessages.push(messageObject);
            }
        }
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        
        // Save messages to localStorage
        saveMessages();
    }

    function saveMessages() {
        // Keep only the latest MAX_MESSAGES
        if (chatMessages.length > MAX_MESSAGES) {
            chatMessages = chatMessages.slice(-MAX_MESSAGES);
        }
        try {
            localStorage.setItem('chatMessages', JSON.stringify(chatMessages));
        } catch (e) {
            console.error("Failed to save messages to localStorage:", e);
            // Optionally, inform the user if storage is full
        }
    }

    function loadMessages() {
        try {
            const storedMessages = localStorage.getItem('chatMessages');
            if (storedMessages) {
                chatMessages = JSON.parse(storedMessages);
                const chatBox = document.getElementById('chatBox');
                chatBox.innerHTML = ''; // Clear existing messages before loading
                chatMessages.forEach(msg => {
                    // Re-render only persistent messages (text, sent files)
                    if (msg.type === 'sent' || msg.type === 'received') {
                        // Reconstruct the message HTML based on its type
                        const div = document.createElement('div');
                        div.id = msg.id;

                        const bubble = document.createElement('div');
                        bubble.className = 'message-bubble relative max-w-md md:max-w-lg px-3 py-2 rounded-lg shadow';

                        if (msg.type === 'sent') {
                            div.className = 'flex justify-end mb-2';
                            bubble.classList.add('sent-bubble');
                            bubble.innerHTML = `${msg.content} <button onclick="deleteMessage('${msg.id}')" class="text-xs font-bold text-red-500 hover:underline ml-2 opacity-50 hover:opacity-100">[X]</button>`;
                        } else { // type === 'received'
                            div.className = 'flex justify-start mb-2';
                            bubble.classList.add('received-bubble');
                            bubble.innerHTML = msg.content;
                        }
                        div.appendChild(bubble);
                        chatBox.appendChild(div);
                    } else if (msg.type === 'system' && msg.content.includes('Receiving file:') && msg.id) {
                        // For file transfer start messages, just log them as system
                        // This helps indicate that a transfer happened, but doesn't re-show progress bars.
                        log(msg.content, 'system', msg.id);
                    }
                });
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        } catch (e) {
            console.error("Failed to load messages from localStorage:", e);
            chatMessages = []; // Reset if corrupted
        }
    }
    
    // --- ENCRYPTION / DECRYPTION ---
    async function encrypt(data) { const enc = new TextEncoder();const iv = crypto.getRandomValues(new Uint8Array(12));const encryptedContent = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, enc.encode(data));const combined = new Uint8Array(iv.byteLength + encryptedContent.byteLength);combined.set(iv, 0);combined.set(new Uint8Array(encryptedContent), iv.byteLength);return combined; }
    async function decrypt(data) { const combined = new Uint8Array(data);const iv = combined.slice(0, 12);const ciphertext = combined.slice(12);const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, ciphertext);return new TextDecoder().decode(decrypted); }

    // --- P2P CORE LOGIC ---
    function initPeer(initiator) {
      peer = new SimplePeer({ initiator, trickle: false });
      peer.on('signal', data => { 
          document.getElementById('signalOut').value = JSON.stringify(data); 
          if (initiator) { // Save local signal only if we are the initiator
            localStorage.setItem('localSignal', JSON.stringify(data));
          }
      });
      peer.on('connect', () => { 
          document.getElementById('setup').classList.add('hidden'); 
          document.getElementById('app').classList.remove('hidden'); 
          log('Connection established!'); 
          loadMessages(); // Load messages when connection is established and app is visible
          
          // Save shared key on successful connection
          localStorage.setItem('sharedKey', document.getElementById('sharedKey').value);
      });
      peer.on('error', err => { console.error('Peer error:', err); log('Connection error.', 'system'); });
      peer.on('close', () => { log('Connection closed.', 'system'); endCall(false); });
      peer.on('stream', stream => { document.getElementById('remoteVideo').srcObject = stream; document.getElementById('video-container').classList.remove('hidden'); });

      peer.on('data', async data => {
        try {
          if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); }
          const decrypted = await decrypt(data);
          const message = JSON.parse(decrypted);

          // --- MESSAGE HANDLER ---
          switch (message.type) {
              case 'text':
                  log(message.content, 'received', message.id);
                  break;
              case 'view-once-text':
                  const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceText(this, '${btoa(JSON.stringify(message.content))}')"><p class="font-bold">👁️ View-Once Message</p><p class="text-xs">Click to reveal</p></div>`;
                  log(placeholderHTML, 'received', message.id); 
                  break;
              case 'delete':
                  const msgEl = document.getElementById(message.id);
                  if (msgEl) {
                      msgEl.remove(); // Direct removal
                      // Also remove from chatMessages array
                      chatMessages = chatMessages.filter(msg => msg.id !== message.id);
                      saveMessages();
                  }
                  break;
              case 'file-meta':
                  receivingFile = { ...message, chunks: [], receivedSize: 0 };
                  log(`Receiving file: <strong>${message.name}</strong> (${(message.size / 1024 / 1024).toFixed(2)} MB)`, 'system', message.id); // Use system type for file progress
                  document.getElementById('progressContainer').style.display = 'flex'; // Use flex for layout
                  document.getElementById('cancelFileBtn').classList.remove('hidden'); // Show cancel button for receiving
                  document.getElementById('progressLabel').textContent = `Receiving ${message.name}...`;
                  break;
              case 'file-chunk':
                  handleFileChunk(message);
                  break;
              case 'file-ack':
                  if (sendingFile.id === message.id) {
                      clearTimeout(sendingFile.ackTimeout);
                      sendingFile.lastAck = message.index;
                      sendChunk();
                  }
                  break;
              case 'file-cancel':
                  if (receivingFile.id === message.id) {
                      log(`File transfer for ${receivingFile.name} cancelled by peer.`, 'system');
                      receivingFile = {}; // Clear receiving state
                      document.getElementById('progressContainer').style.display = 'none';
                      document.getElementById('cancelFileBtn').classList.add('hidden'); // Hide cancel button
                  }
                  break;
              case 'call-invite':
                  showIncomingCall(message.callType);
                  break;
              case 'call-accept':
                  log('Call accepted. Starting stream...', 'system');
                  startStream(message.callType);
                  document.getElementById('video-container').classList.remove('hidden');
                  break;
              case 'call-decline':
                  log('Peer declined the call.', 'system');
                  document.getElementById('video-container').classList.add('hidden');
                  break;
              case 'call-ended':
                  log('Peer ended the call.', 'system');
                  endCall(false); // Do not notify peer back
                  break;
          }
        } catch(e) { console.error(e); log('Failed to process message.', 'system'); }
      });
    }

    async function sendPacket(message) { 
        if (!peer || !peer.connected) { log('Not connected.', 'system'); return false; } 
        if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); } 
        try { 
            peer.send(await encrypt(JSON.stringify(message))); 
            return true; 
        } catch (err) { 
            console.error("Send failed:", err); 
            log(`Failed to send packet.`, 'system'); 
            return false; 
        } 
    }
    async function sendMessage() { 
        const msgInput = document.getElementById('message');
        if (!msgInput.value.trim()) return; // Prevent sending empty messages

        const messageContent = msgInput.value.replace(/\n/g, '<br>');
        const isViewOnce = document.getElementById('viewOnce').checked;
        const messageId = `msg-${Date.now()}`;
        const messageType = isViewOnce ? 'view-once-text' : 'text';

        if (await sendPacket({ type: messageType, content: messageContent, id: messageId })) {
            if (!isViewOnce) {
                const sentHTML = `${messageContent} <button onclick="deleteMessage('${messageId}')" class="text-xs font-bold text-red-500 hover:underline ml-2 opacity-50 hover:opacity-100">[X]</button>`;
                log(sentHTML, 'sent', messageId);
            } else {
                log(`<i>Sent a 'view-once' message.</i>`, 'sent', messageId); 
            }
            msgInput.value = ''; 
            msgInput.style.height = 'auto';
            document.getElementById('viewOnce').checked = false;
        } 
    }

    // --- VIEW-ONCE, DELETE & FULLSCREEN ---
    function revealOnceText(element, encodedContent) { 
        element.innerHTML = JSON.parse(atob(encodedContent));
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
        setTimeout(() => element.parentElement.remove(), 8000); 
    }
    
    function revealOnceMedia(element, blobId) {
        const blobInfo = viewOnceBlobs[blobId];
        if (!blobInfo) return;
        if (blobInfo.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = blobInfo.url;
            img.className = "max-w-xs rounded-lg";
            img.alt = "View-once Image";
            img.oncontextmenu = () => false; // Prevent right-click save
            element.innerHTML = '';
            element.appendChild(img);
            setTimeout(() => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            }, 5000);
        } else if (blobInfo.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = blobInfo.url;
            video.autoplay = true;
            video.className = "max-w-xs rounded-lg";
            video.oncontextmenu = () => false; // Prevent right-click save
            video.onended = () => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            };
            element.innerHTML = '';
            element.appendChild(video);
        }
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
    }
    function showFullscreenImage(src) { document.getElementById('fullscreen-image').src = src; document.getElementById('fullscreen-viewer').classList.remove('hidden'); }
    function hideFullscreenImage() { document.getElementById('fullscreen-viewer').classList.add('hidden'); }

    async function deleteMessage(messageId) {
        // Find and remove from chatMessages array first
        chatMessages = chatMessages.filter(msg => msg.id !== messageId);
        saveMessages();

        if (await sendPacket({ type: 'delete', id: messageId })) {
            const msgElementToRemove = document.getElementById(messageId);
            if (msgElementToRemove) {
                msgElementToRemove.remove(); 
            }
        }
    }

    // --- FILE TRANSFER ---
    async function handleFileChunk(message) {
      if (receivingFile.id !== message.id) return;
      const chunk = Uint8Array.from(atob(message.chunk), c => c.charCodeAt(0));
      receivingFile.chunks[message.index] = chunk; receivingFile.receivedSize += chunk.byteLength;
      document.getElementById('progressBar').style.width = `${(receivingFile.receivedSize / receivingFile.size) * 100}%`;
      await sendPacket({ type: 'file-ack', id: message.id, index: message.index });
      if (receivingFile.receivedSize === receivingFile.size) {
          const fileBlob = new Blob(receivingFile.chunks, {type: receivingFile.fileType});
          if (receivingFile.isViewOnce) {
              const blobId = `blob-${Date.now()}`;
              viewOnceBlobs[blobId] = { url: URL.createObjectURL(fileBlob), type: receivingFile.fileType, name: receivingFile.name };
              const mediaIcon = receivingFile.fileType.startsWith('image/') ? '🖼️' : '🎬';
              const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceMedia(this, '${blobId}')"><p class="font-bold">${mediaIcon} View-Once Media</p><p class="text-xs>${receivingFile.name} - Click to reveal</p></div>`;
              log(placeholderHTML, 'received', receivingFile.id); 
          } else {
              const url = URL.createObjectURL(fileBlob);
              let mediaHTML = '';
              if (receivingFile.fileType.startsWith('image/')) {
                  mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Received Image" onclick="showFullscreenImage(this.src)">`;
              } else if (receivingFile.fileType.startsWith('video/')) {
                  mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
              }
              const downloadUI = `<div class="mt-2 p-2 bg-gray-100 dark:bg-gray-600 rounded-lg flex items-center justify-between"><div class="text-sm"><strong>${receivingFile.name}</strong></div><a href="${url}" download="${receivingFile.name}" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-500"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg></a></div>`;
              log(mediaHTML + downloadUI, 'received', receivingFile.id); 
          }
          receivingFile = {};
          setTimeout(() => { 
            document.getElementById('progressContainer').style.display = 'none'; 
            document.getElementById('cancelFileBtn').classList.add('hidden'); 
          }, 2000);
      }
    }

    function prepareFile(event) { 
        const file = event.target.files[0];
        if (!file) return;
        if (sendingFile.id) { log('A file transfer is already in progress.', 'system'); return; }
        
        const isViewOnce = document.getElementById('viewOnce').checked;
        const fileId = `file-${Date.now()}`;
        
        log(`Preparing to send: <strong>${file.name}</strong>...`, 'system', fileId);
        document.getElementById('progressContainer').style.display = 'flex'; 
        document.getElementById('cancelFileBtn').classList.remove('hidden'); 
        document.getElementById('progressLabel').textContent = `Sending ${file.name}...`;
        document.getElementById('progressBar').style.width = '0%';

        fileReader = new FileReader(); 
        fileReader.onload = async (e) => {
            sendingFile = { 
                id: fileId, name: file.name, type: file.type, size: file.size, isViewOnce, 
                chunks: [], buffer: e.target.result, currentIndex: 0, lastAck: -1 
            };
            for (let i = 0; i < e.target.result.byteLength; i += CHUNK_SIZE) {
                sendingFile.chunks.push(e.target.result.slice(i, i + CHUNK_SIZE));
            }
            if(await sendPacket({ type: 'file-meta', id: fileId, name: file.name, size: file.size, fileType: file.type, isViewOnce })) {
                sendChunk();
                document.getElementById('viewOnce').checked = false;
            } else { 
                log(`Could not initiate file transfer.`, 'system'); 
                cancelFileTransfer(false); 
            }
        };
        fileReader.onerror = (e) => {
            console.error("FileReader error:", e);
            log("Error reading file for transfer.", "system");
            cancelFileTransfer(false);
        };
        fileReader.readAsArrayBuffer(file); 
        event.target.value = null; 
    }

    function sendChunk() {
        if (!sendingFile.id || sendingFile.currentIndex > sendingFile.lastAck + 1) return;
        if (sendingFile.currentIndex >= sendingFile.chunks.length) {
            if (!sendingFile.isViewOnce) {
                const fileBlob = new Blob([sendingFile.buffer], {type: sendingFile.type});
                const url = URL.createObjectURL(fileBlob);
                let mediaHTML = '';
                if (sendingFile.type.startsWith('image/')) {
                    mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Sent Image" onclick="showFullscreenImage(this.src)">`;
                } else if (sendingFile.type.startsWith('video/')) {
                    mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
                }
                log(mediaHTML, 'sent', sendingFile.id); 
            } else {
                log(`<i>Sent a 'view-once' file.</i>`, 'sent', sendingFile.id); 
            }
            setTimeout(() => { 
                document.getElementById('progressContainer').style.display = 'none'; 
                document.getElementById('cancelFileBtn').classList.add('hidden'); 
            }, 2000);
            sendingFile = {}; 
            return;
        }
        const chunk = sendingFile.chunks[sendingFile.currentIndex];
        const base64Chunk = btoa(new Uint8Array(chunk).reduce((data, byte) => data + String.fromCharCode(byte), ''));
        sendPacket({ type: 'file-chunk', id: sendingFile.id, index: sendingFile.currentIndex, chunk: base64Chunk }).then(sent => {
            if (sent) {
                sendingFile.ackTimeout = setTimeout(() => { log(`No ACK for chunk ${sendingFile.currentIndex}, retrying...`, 'system'); sendChunk(); }, 10000);
                document.getElementById('progressBar').style.width = `${((sendingFile.currentIndex + 1) / sendingFile.chunks.length) * 100}%`;
                if (sendingFile.currentIndex === sendingFile.lastAck + 1) sendingFile.currentIndex++;
            } else { 
                log(`Critical send failure for chunk ${sendingFile.currentIndex}. Aborting transfer.`, 'system'); 
                clearTimeout(sendingFile.ackTimeout); 
                cancelFileTransfer(false); 
            }
        });
    }

    function cancelFileTransfer(shouldNotifyPeer) {
        if (fileReader) {
            fileReader.abort(); 
            fileReader = null;
        }
        if (sendingFile.id && shouldNotifyPeer) {
            sendPacket({ type: 'file-cancel', id: sendingFile.id });
            log(`File transfer for ${sendingFile.name} cancelled.`, 'system');
        } else if (receivingFile.id && shouldNotifyPeer) {
             // This branch handles a local cancel of a *receiving* file, which isn't directly exposed by a button but is here for completeness.
            sendPacket({ type: 'file-cancel', id: receivingFile.id }); // Tell sender we cancelled
            log(`Receiving file transfer for ${receivingFile.name} cancelled.`, 'system');
        }
        
        clearTimeout(sendingFile.ackTimeout); 
        sendingFile = {}; 
        receivingFile = {}; 

        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('cancelFileBtn').classList.add('hidden'); 
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressLabel').textContent = '';
    }


    // --- CALLING LOGIC ---
    async function initiateCall(callType) {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        if (!peer?.connected) { log('Connect to a peer before calling.', 'system'); return; }
        currentCallType = callType; 
        log(`Inviting peer to a ${callType} call...`, 'system');
        if (await sendPacket({ type: 'call-invite', callType: callType })) {
            document.getElementById('video-container').classList.remove('hidden');
            startStream(callType);
        } else {
            log('Failed to send call invite.', 'system');
        }
    }

    function showIncomingCall(callType) {
        const notice = document.getElementById('incoming-call-notice');
        document.getElementById('incoming-call-text').textContent = `Peer is inviting you to a ${callType} call.`;
        notice.classList.remove('hidden');
        document.getElementById('decline-call-btn').onclick = () => {
            sendPacket({ type: 'call-decline' });
            notice.classList.add('hidden');
            document.getElementById('video-container').classList.add('hidden');
        };
        document.getElementById('accept-call-btn').onclick = () => {
            sendPacket({ type: 'call-accept', callType: callType });
            startStream(callType);
            document.getElementById('video-container').classList.remove('hidden');
            notice.classList.add('hidden');
        };
    }

    async function startStream(callType) {
      try {
        const constraints = {
            audio: true,
            video: callType === 'video'
        };
        localStream = await navigator.mediaDevices.getUserMedia(constraints);

        if (callType === 'audio') {
            document.getElementById('videoBtn').classList.add('hidden');
            document.getElementById('localVideo').muted = true;
        } else {
            document.getElementById('videoBtn').classList.remove('hidden');
            document.getElementById('localVideo').muted = true; 
        }

        document.getElementById('localVideo').srcObject = localStream;

        if (peer && peer.connected) {
            peer._pc.getSenders().forEach(sender => {
                if (sender.track) {
                    peer.removeTrack(sender.track);
                }
            });
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
        } else {
             log('Peer not connected, cannot add stream.', 'system');
             endCall(false); 
             return;
        }

        document.getElementById('video-container').classList.remove('hidden');

      } catch (err) {
        console.error('Media access error:', err);
        if (err.name === 'NotAllowedError') {
          alert("Permission to access camera/mic was denied.");
          log('Could not start call: permission denied.', 'system');
        } else if (err.name === 'NotFoundError') {
          alert("No camera or microphone found.");
          log('Could not start call: no input devices found.', 'system');
        } else if (err.name === 'NotReadableError') {
          alert("Camera/mic is in use by another application.");
          log('Could not start call: input device busy.', 'system');
        } else {
          alert("Unexpected error accessing media devices.");
          log(`Could not start call: ${err.name}.`, 'system');
        }
        endCall(true);
      }
    }

    function endCall(shouldNotifyPeer) {
        if (shouldNotifyPeer && peer && peer.connected) {
            sendPacket({ type: 'call-ended' });
        }
        if (localStream) {
            localStream.getTracks().forEach(track => {
                track.stop(); 
                if (peer && peer._pc) {
                    const sender = peer._pc.getSenders().find(s => s.track === track);
                    if (sender) {
                        peer.removeTrack(sender);
                    }
                }
            });
            localStream = null; 
        }
        document.getElementById('video-container').classList.add('hidden');
        document.getElementById('localVideo').srcObject = null;
        document.getElementById('remoteVideo').srcObject = null;
        log('Call ended.', 'system');
    }

    function toggleAudio() { 
        if (localStream && localStream.getAudioTracks().length > 0) {
            const audioTrack = localStream.getAudioTracks()[0];
            audioTrack.enabled = !audioTrack.enabled; 
            document.getElementById('audioBtn').textContent = audioTrack.enabled ? 'Mute' : 'Unmute'; 
        }
    }
    function toggleVideo() { 
        if (localStream && localStream.getVideoTracks().length > 0) {
            const videoTrack = localStream.getVideoTracks()[0];
            videoTrack.enabled = !videoTrack.enabled;
            document.getElementById('videoBtn').textContent = videoTrack.enabled ? 'Cam Off' : 'Cam On';
        }
    }

    // Auto-resize textarea
    document.getElementById('message').addEventListener('input', (e) => { e.target.style.height = 'auto'; e.target.style.height = (e.target.scrollHeight) + 'px'; });

    // Initial load of theme and persisted connection data
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme && themes.includes(savedTheme)) {
            document.body.classList.add(savedTheme);
            currentThemeIndex = themes.indexOf(savedTheme);
        } else {
            // Default to 'light' if no theme saved or invalid theme
            document.body.classList.add('light');
            localStorage.setItem('theme', 'light');
            currentThemeIndex = 0;
        }

        const savedKey = localStorage.getItem('sharedKey');
        const savedSignal = localStorage.getItem('localSignal');

        if (savedKey) {
            document.getElementById('sharedKey').value = savedKey;
        }
        if (savedSignal) {
            document.getElementById('signalOut').value = savedSignal;
        }
        
        // If there's a stored key or signal, we can make the connect button more prominent
        // Or provide a hint to the user.
        if (savedKey || savedSignal) {
            logToSetup('Connection details found. Enter peer\'s signal to reconnect, or click "Start New Connection".');
        }
    });

  </script>
</body>
</html>
