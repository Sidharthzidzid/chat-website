<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encrypted P2P Chat & Call</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Base Chat Backgrounds & General Colors */
    body.light { background-color: #f0f0f0; color: #212121; } /* Changed text color to a darker shade */
    body.dark { background-color: #1a1a1a; color: #eee; }
    body.theme-3 { background-color: #e0f2f7; color: #212121; } /* Light blue */
    body.theme-4 { background-color: #f0fff4; color: #222; } /* Light green */

    /* Chat Box Backgrounds */
    body.light .chat-bg {
      background-color: #e5ddd5;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 800 800"><g fill="%23cbc5bd" fill-opacity="0.4"><path d="M0 0h800v800H0z"/><path d="M283.25 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zM0 283.25c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm583.25-100c55.25 0 100 44.75 100 100v100h-200V183.25c0-55.25 44.75-100 100-100zM0 516.75c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm283.25 100c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm266.5-100c55.25 0 100 44.75 100 100v100h-200V516.75c0-55.25 44.75-100 100-100z"/></g></svg>');
    }
    body.dark .chat-bg { background-color: #0d1418; }
    body.theme-3 .chat-bg { background-color: #bbdefb; } /* Lighter blue for chat background */
    body.theme-4 .chat-bg { background-color: #c8e6c9; } /* Lighter green for chat background */


    /* Header/Footer Backgrounds */
    body.light header, body.light footer { background-color: #f0f0f0; }
    body.dark header, body.dark footer { background-color: #1f2c34; }
    body.theme-3 header, body.theme-3 footer { background-color: #81d4fa; } /* Bright blue */
    body.theme-4 header, body.theme-4 footer { background-color: #a5d6a7; } /* Muted green */

    /* Header/Footer Text Colors */
    body.light header, body.light header h2, body.light header button { color: #212121; }
    body.dark header, body.dark header h2, body.dark header button { color: #ffffff; }
    body.theme-3 header, body.theme-3 header h2, body.theme-3 header button { color: #01579B; } /* Dark blue for theme-3 header text */
    body.theme-4 header, body.theme-4 header h2, body.theme-4 header button { color: #1B5E20; } /* Dark green for theme-4 header text */

    /* Input/Textarea Backgrounds */
    body.light input, body.light textarea { background-color: #fff; border-color: #ddd; color: #212121; } /* Changed text color to a darker shade */
    body.dark input, body.dark textarea { background-color: #2a3942; border-color: #555; color: #eee; }
    body.theme-3 input, body.theme-3 textarea { background-color: #e3f2fd; border-color: #90caf9; color: #212121; }
    body.theme-4 input, body.theme-4 textarea { background-color: #e8f5e9; border-color: #a5d6a7; color: #222; }
    
    /* Sent Bubbles */
    .sent-bubble { background-color: #dcf8c6; color: #212121; } /* Changed text color to a darker shade */
    .dark .sent-bubble { background-color: #056162; color: #eee; } /* Default dark green */
    .theme-3 .sent-bubble { background-color: #4fc3f7; color: #fff; } /* Blue for sent */
    .theme-4 .sent-bubble { background-color: #66bb6a; color: #fff; } /* Green for sent */

    /* Received Bubbles */
    .received-bubble { background-color: #ffffff; color: #212121; } /* Changed text color to a darker shade */
    .dark .received-bubble { background-color: #2a3942; color: #eee; } /* Default dark grey */
    .theme-3 .received-bubble { background-color: #e1f5fe; color: #212121; } /* Light blue for received */
    .theme-4 .received-bubble { background-color: #f1f8e9; color: #222; } /* Light yellow-green for received */


    /* Tail for Bubbles */
    .message-bubble:after {
        content: ''; position: absolute; top: 0; width: 0; height: 0; border: 10px solid transparent;
    }
    .sent-bubble:after { right: -10px; }
    .received-bubble:after { left: -10px; }

    /* Tail colors based on theme */
    .light .sent-bubble:after { border-left-color: #dcf8c6; }
    .dark .sent-bubble:after { border-left-color: #056162; }
    .theme-3 .sent-bubble:after { border-left-color: #4fc3f7; }
    .theme-4 .sent-bubble:after { border-left-color: #66bb6a; }

    .light .received-bubble:after { border-right-color: #ffffff; }
    .dark .received-bubble:after { border-right-color: #2a3942; }
    .theme-3 .received-bubble:after { border-right-color: #e1f5fe; }
    .theme-4 .received-bubble:after { border-right-color: #f1f8e9; }


    /* Scrollbar */
    #chatBox::-webkit-scrollbar { width: 6px; }
    #chatBox::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
    body.dark #chatBox::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }
  
    /* Make video-call-container full screen overlay */
    #video-call-container {
        position: fixed; /* Make it an overlay */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 50; /* Ensure it's above the chat but below notification */
        display: flex; /* Always flex, hide with 'hidden' class */
        flex-direction: column;
        background-color: rgba(0, 0, 0, 0.9); /* Slightly transparent dark background */
        color: white;
    }

    #video-call-container.hidden {
        display: none;
    }

    /* Style for the video elements to fill space */
    #video-call-container .flex-grow { /* This targets the div containing local and remote video */
        position: relative; /* For absolute positioning of inner videos */
        width: 100%;
        height: 100%;
        display: flex; /* Use flex to align status text */
        align-items: center;
        justify-content: center;
        overflow: hidden; /* Hide anything outside video boundaries */
    }

    /* Remote Video (main view) */
    #remoteVideoContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #1f2937; /* Dark background for empty video area */
    }
    #remoteVideo {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Fill the container, cropping if necessary */
    }

    /* Local Video (small overlay) */
    #localVideoContainer {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        width: 120px; /* Smaller size */
        height: 90px;
        z-index: 60; /* Above remote video */
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5);
        transform: scaleX(-1); /* Mirror local video */
        background-color: #1f2937; /* Dark background for empty video area */
    }
    #localVideo {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Fill the container */
    }

    #status {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        font-size: 1.5rem;
        z-index: 65; /* Above videos, below local video overlay */
    }

    /* Controls container at the bottom */
    #video-controls {
        display: flex;
        justify-content: center;
        padding: 1rem;
        background-color: rgba(0,0,0,0.6); /* Semi-transparent background for controls */
        z-index: 70;
    }

    /* Incoming Call Notification */
    #incoming-call-notification {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 30px;
        border-radius: 15px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    #incoming-call-notification h3 {
        font-size: 2rem;
        margin-bottom: 20px;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
  </style>
</head>
<body>

  <div id="app" class="h-screen w-screen flex flex-col hidden">
    <header class="p-3 flex items-center justify-between shadow-sm z-10">
      <h2 class="text-lg font-medium">Encrypted P2P Chat</h2>
      <div class="flex items-center space-x-2">
          <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h1M3 12H2m8.006-7.5l-.574-.574m-9.454 9.454l-.574-.574M19 12a7 7 0 11-14 0 7 7 0 0114 0zm-9.146 5.146l.574.574m9.454-9.454l-.574-.574" />
              </svg>
          </button>
          <button onclick="startOrToggleCallUI()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
              </svg>
          </button>
      </div>
    </header>

    <main id="chatBox" class="flex-grow p-4 overflow-y-auto chat-bg"></main>

    <div id="progressContainer" class="px-4 pb-2 chat-bg flex items-center space-x-2" style="display: none;">
        <div class="flex-grow">
            <div class="text-sm text-gray-600 dark:text-gray-400 mb-1" id="progressLabel"></div>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
              <div id="progressBar" class="bg-green-500 h-2.5 rounded-full transition-all duration-150" style="width: 0%"></div>
            </div>
        </div>
        <button id="cancelFileBtn" onclick="cancelFileTransfer(true)" class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm hidden">Cancel</button>
    </div>

    <footer class="p-2 flex items-center space-x-2">
        <label class="flex items-center space-x-1 cursor-pointer p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600" title="Send as a view-once message or file">
            <input type="checkbox" id="viewOnce" class="form-checkbox h-4 w-4 text-green-600 bg-gray-100 dark:bg-gray-900 border-gray-300 dark:border-gray-600 rounded focus:ring-green-500">
            <span class="text-xs text-gray-500">View Once</span>
        </label>
        <input type="file" id="mediaInput" onchange="prepareFile(event)" class="hidden" />
        <label for="mediaInput" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>
        </label>
        <textarea id="message" placeholder="Type a message" class="flex-grow p-2 rounded-full border focus:outline-none focus:ring-2 focus:ring-green-500" rows="1" onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"></textarea>
        <button onclick="sendMessage()" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
        </button>
    </footer>
  </div>

  <div id="video-call-container" class="hidden">
      <div class="flex-grow relative"> <div id="remoteVideoContainer" class="bg-gray-800 flex items-center justify-center rounded-lg overflow-hidden">
              <video id="remoteVideo" autoplay playsinline class="w-full h-full"></video>
              <div id="status" class="absolute text-gray-400 p-4 text-center">Waiting to connect...</div>
          </div>
          <div id="localVideoContainer" class="rounded-lg shadow-lg">
              <video id="localVideo" autoplay playsinline muted class="w-full h-full"></video>
          </div>
      </div>

      <div id="video-controls" class="pt-2"> <button id="callButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-full transition-colors text-lg disabled:opacity-50 mx-2" disabled>Start Call</button>
          <button id="hangupButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-full transition-colors text-lg disabled:opacity-50 mx-2" disabled>Hang Up</button>
      </div>
  </div>

  <div id="incoming-call-notification" class="hidden">
      <h3>Incoming Video Call!</h3>
      <p class="mb-4">From your peer</p>
      <div class="flex justify-center space-x-4">
          <button id="acceptCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full text-lg">Accept</button>
          <button id="rejectCallButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full text-lg">Reject</button>
      </div>
  </div>

  <div id="setup" class="min-h-screen bg-gray-100 dark:bg-gray-900 flex items-center justify-center p-4">
      <div class="max-w-xl w-full bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg space-y-4">
          <h2 class="text-2xl font-bold text-center text-gray-800 dark:text-gray-200">Setup Secure Connection</h2>
          <div><label class="font-bold text-gray-600 dark:text-gray-400">1. Enter a Shared Secret (Password)</label><input type="text" id="sharedKey" placeholder="Must match your peer's secret" oninput="checkStrength()" class="w-full mt-1 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded" /><div id="strengthMeter" class="text-sm mt-1"></div></div>
          <div class="grid md:grid-cols-2 gap-4">
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">2. Start & Share Your Signal</label><button onclick="startChat()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Start New Chat</button><textarea id="signalOut" placeholder="Your signal data appears here..." class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="copySignal()" class="w-full bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded">Copy Signal</button></div>
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">3. Paste Peer's Signal & Connect</label><textarea id="signalIn" placeholder="Paste peer's signal data here" class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="connect()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Connect</button></div>
          </div>
          <button onclick="newConnection()" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded mt-4">Start New Connection</button>
          <div id="log" class="text-center text-sm text-gray-500 dark:text-gray-400"></div>
      </div>
  </div>
  
  <div id="fullscreen-viewer" onclick="hideFullscreenImage()" class="hidden fixed inset-0 bg-black bg-opacity-80 z-40 flex items-center justify-center p-4 cursor-pointer">
      <img id="fullscreen-image" src="" class="max-w-full max-h-full">
      <button onclick="hideFullscreenImage()" class="absolute top-5 right-5 text-white text-4xl font-bold">&times;</button>
  </div>

  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script>
    let peer, aesKey;
    let receivingFile = {}, sendingFile = {};
    let viewOnceBlobs = {};
    let chatMessages = []; // Array to store message objects for localStorage
    const MAX_MESSAGES = 100; // Limit for messages to store in localStorage
    const CHUNK_SIZE = 64 * 1024;
    let fileReader = null; // Reference to FileReader for cancellation

    // Define the themes and their names
    const themes = ['light', 'dark', 'theme-3', 'theme-4'];
    let currentThemeIndex = 0;

    // WebRTC elements and variables
    const servers = { iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };
    let rtcPeerConnection = null;
    let localStream = null;
    let incomingCallOffer = null; // To store the received offer until accepted/rejected
    
    // Removed startButton as its functionality is now merged
    const callButton = document.getElementById('callButton'); // Renamed from startVideoCallButton
    const hangupButton = document.getElementById('hangupButton');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const statusDiv = document.getElementById('status');
    const videoCallContainer = document.getElementById('video-call-container');
    const incomingCallNotification = document.getElementById('incoming-call-notification');
    const acceptCallButton = document.getElementById('acceptCallButton');
    const rejectCallButton = document.getElementById('rejectCallButton');

    // --- UTILITY & SETUP ---
    function toggleTheme() {
        // Remove all existing theme classes
        document.body.classList.remove(...themes);

        // Move to the next theme
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        const newTheme = themes[currentThemeIndex];

        // Apply the new theme
        document.body.classList.add(newTheme);
        localStorage.setItem('theme', newTheme); // Save theme preference
    }

    // Function to start a call or toggle video call UI visibility
    async function startOrToggleCallUI() {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }

        // If video container is hidden, it means we want to open it and potentially start a call
        if (videoCallContainer.classList.contains('hidden')) {
            videoCallContainer.classList.remove('hidden');
            // If there's no active call, attempt to start one immediately
            if (!rtcPeerConnection) {
                try {
                    statusDiv.textContent = "Requesting camera access...";
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    localVideo.srcObject = localStream;
                    statusDiv.textContent = "Camera on. Initiating call...";
                    setupPeerConnection(true); // True indicates this peer is the initiator
                    // Offer creation and sending happens inside setupPeerConnection's onnegotiationneeded
                } catch (error) {
                    console.error("Error accessing media devices.", error);
                    alert("Could not access your camera. Please grant permissions or ensure no other app is using it.");
                    statusDiv.textContent = "Error: Camera access denied.";
                    videoCallContainer.classList.add('hidden'); // Hide UI if camera fails
                    hangUp(); // Clean up any partial state
                }
            } else {
                // If rtcPeerConnection exists, it means a call is active/incoming/connecting, just show UI
                statusDiv.textContent = "Call active.";
            }
        } else {
            // If video container is visible and we click again, it means we want to close/hang up
            if (rtcPeerConnection) {
                // If a call is active, clicking the icon again should hang up
                hangUp();
            }
            videoCallContainer.classList.add('hidden');
        }
        updateVideoCallButtonsState();
    }


    function logToSetup(msg) { document.getElementById('log').textContent = msg; }
    async function deriveKey(password) { const enc = new TextEncoder();const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);return crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode("p2p-chat-salt"), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]); }
    function checkStrength() { const val = document.getElementById('sharedKey').value;const meter = document.getElementById('strengthMeter');if (val.length > 15 && /[A-Z]/.test(val) && /[0-9]/.test(val) && /[^A-Za-z0-9]/.test(val)) {meter.textContent = '🔒 Strong Password'; meter.className = 'text-sm mt-1 text-green-500';} else if (val.length > 8) {meter.textContent = '🟡 Medium Strength'; meter.className = 'text-sm mt-1 text-yellow-500';} else {meter.textContent = '🔓 Weak Password'; meter.className = 'text-sm mt-1 text-red-500';}}
    function startChat() { 
        if (!document.getElementById('sharedKey').value) { logToSetup('Please enter a shared secret first.'); return; } 
        initPeer(true); 
        logToSetup('Signal generated. Copy and send it to your peer.'); 
    }
    function connect() { 
        if (!document.getElementById('sharedKey').value) { logToSetup('Please enter a shared secret first.'); return; } 
        if (!document.getElementById('signalIn').value) { logToSetup('Please paste the peer\'s signal first.'); return; } 
        if (!peer) initPeer(false); 
        try { 
            peer.signal(JSON.parse(document.getElementById('signalIn').value)); 
        } catch { 
            logToSetup('⚠️ Invalid signal data'); 
        } 
    }
    function copySignal() { 
        const out = document.getElementById('signalOut');
        if (!out.value) { logToSetup('Generate a signal first!'); return; }
        navigator.clipboard.writeText(out.value).then(() => logToSetup('Signal copied to clipboard.'), () => logToSetup('Failed to copy signal.')); 
    }

    function newConnection() {
        localStorage.removeItem('sharedKey');
        localStorage.removeItem('localSignal');
        localStorage.removeItem('chatMessages'); // Clear chat history for new connection
        window.location.reload(); // Reload the page to reset everything
    }
    
    // --- UI & LOGGING ---
    function log(content, type = 'system', msgId = '') {
        const chatBox = document.getElementById('chatBox');
        const div = document.createElement('div');

        // Store message object for localStorage
        const messageObject = { content, type, id: msgId, timestamp: Date.now() };
        
        if (type === 'system') {
            div.className = 'text-center my-2';
            div.innerHTML = `<span class="bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs font-semibold px-2 py-1 rounded-full">${content}</span>`;
            // System messages are not saved in chat history for simplicity,
            // but you could add them if desired.
            if (msgId && !content.includes('Receiving file:') && !content.includes('Preparing to send:')) { // Only save system messages related to file transfer start for re-render
                // For simplicity, we don't re-render progress updates or call logs from history.
                // We save meta, but actual logging happens in real-time.
            }
        } else {
            const bubble = document.createElement('div');
            div.id = msgId; // Apply ID to the outer div

            bubble.className = 'message-bubble relative max-w-md md:max-lg px-3 py-2 rounded-lg shadow';

            if (type === 'sent') {
                div.className = 'flex justify-end mb-2';
                bubble.classList.add('sent-bubble');
            } else {
                div.className = 'flex justify-start mb-2';
                bubble.classList.add('received-bubble');
            }
            bubble.innerHTML = content;
            div.appendChild(bubble);

            // Add to chatMessages array only for 'sent' and 'received' messages
            // Don't save HTML for 'view-once' as it's dynamic
            if (type !== 'view-once-text' && !content.includes('View-Once Media')) {
                chatMessages.push(messageObject);
            }
        }
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        
        // Save messages to localStorage
        saveMessages();
    }

    function saveMessages() {
        // Keep only the latest MAX_MESSAGES
        if (chatMessages.length > MAX_MESSAGES) {
            chatMessages = chatMessages.slice(-MAX_MESSAGES);
        }
        try {
            localStorage.setItem('chatMessages', JSON.stringify(chatMessages));
        } catch (e) {
            console.error("Failed to save messages to localStorage:", e);
            // Optionally, inform the user if storage is full
        }
    }

    function loadMessages() {
        try {
            const storedMessages = localStorage.getItem('chatMessages');
            if (storedMessages) {
                chatMessages = JSON.parse(storedMessages);
                const chatBox = document.getElementById('chatBox');
                chatBox.innerHTML = ''; // Clear existing messages before loading
                chatMessages.forEach(msg => {
                    // Re-render only persistent messages (text, sent files)
                    if (msg.type === 'sent' || msg.type === 'received') {
                        // Reconstruct the message HTML based on its type
                        const div = document.createElement('div');
                        div.id = msg.id;

                        const bubble = document.createElement('div');
                        bubble.className = 'message-bubble relative max-w-md md:max-lg px-3 py-2 rounded-lg shadow';

                        if (msg.type === 'sent') {
                            div.className = 'flex justify-end mb-2';
                            bubble.classList.add('sent-bubble');
                            bubble.innerHTML = `${msg.content} <button onclick="deleteMessage('${msg.id}')" class="text-xs font-bold text-red-500 hover:underline ml-2 opacity-50 hover:opacity-100">[X]</button>`;
                        } else { // type === 'received'
                            div.className = 'flex justify-start mb-2';
                            bubble.classList.add('received-bubble');
                            bubble.innerHTML = msg.content;
                        }
                        div.appendChild(bubble);
                        chatBox.appendChild(div);
                    } else if (msg.type === 'system' && msg.content.includes('Receiving file:') && msg.id) {
                        // For file transfer start messages, just log them as system
                        // This helps indicate that a transfer happened, but doesn't re-show progress bars.
                        log(msg.content, 'system', msg.id);
                    }
                });
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        } catch (e) {
            console.error("Failed to load messages from localStorage:", e);
            chatMessages = []; // Reset if corrupted
        }
    }
    
    // --- ENCRYPTION / DECRYPTION ---
    async function encrypt(data) { const enc = new TextEncoder();const iv = crypto.getRandomValues(new Uint8Array(12));const encryptedContent = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, enc.encode(data));const combined = new Uint8Array(iv.byteLength + encryptedContent.byteLength);combined.set(iv, 0);combined.set(new Uint8Array(encryptedContent), iv.byteLength);return combined; }
    async function decrypt(data) { const combined = new Uint8Array(data);const iv = combined.slice(0, 12);const ciphertext = combined.slice(12);const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, ciphertext);return new TextDecoder().decode(decrypted); }

    // --- P2P CORE LOGIC ---
    function initPeer(initiator) {
      peer = new SimplePeer({ initiator, trickle: false });
      peer.on('signal', data => { 
          document.getElementById('signalOut').value = JSON.stringify(data); 
          if (initiator) { // Save local signal only if we are the initiator
            localStorage.setItem('localSignal', JSON.stringify(data));
          }
      });
      peer.on('connect', () => { 
          document.getElementById('setup').classList.add('hidden'); 
          document.getElementById('app').classList.remove('hidden'); 
          log('Connection established!'); 
          loadMessages(); // Load messages when connection is established and app is visible
          
          // Save shared key on successful connection
          localStorage.setItem('sharedKey', document.getElementById('sharedKey').value);

          // Enable video call buttons once SimplePeer is connected
          updateVideoCallButtonsState();
      });
      peer.on('error', err => { console.error('Peer error:', err); log('Connection error.', 'system'); hangUp(); }); // Hang up video call on chat error
      peer.on('close', () => { log('Connection closed.', 'system'); hangUp(); }); // Hang up video call on chat close

      peer.on('data', async data => {
        try {
          if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); }
          const decrypted = await decrypt(data);
          const message = JSON.parse(decrypted);

          // --- MESSAGE HANDLER ---
          switch (message.type) {
              case 'text':
                  log(message.content, 'received', message.id);
                  break;
              case 'view-once-text':
                  const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceText(this, '${btoa(JSON.stringify(message.content))}')"><p class="font-bold">👁️ View-Once Message</p><p class="text-xs">Click to reveal</p></div>`;
                  log(placeholderHTML, 'received', message.id); 
                  break;
              case 'delete':
                  const msgEl = document.getElementById(message.id);
                  if (msgEl) {
                      msgEl.remove(); // Direct removal
                      // Also remove from chatMessages array
                      chatMessages = chatMessages.filter(msg => msg.id !== message.id);
                      saveMessages();
                  }
                  break;
              case 'file-meta':
                  receivingFile = { ...message, chunks: [], receivedSize: 0 };
                  log(`Receiving file: <strong>${message.name}</strong> (${(message.size / 1024 / 1024).toFixed(2)} MB)`, 'system', message.id); // Use system type for file progress
                  document.getElementById('progressContainer').style.display = 'flex'; // Use flex for layout
                  document.getElementById('cancelFileBtn').classList.remove('hidden'); // Show cancel button for receiving
                  document.getElementById('progressLabel').textContent = `Receiving ${message.name}...`;
                  break;
              case 'file-chunk':
                  handleFileChunk(message);
                  break;
              case 'file-ack':
                  if (sendingFile.id === message.id) {
                      clearTimeout(sendingFile.ackTimeout);
                      sendingFile.lastAck = message.index;
                      sendChunk();
                  }
                  break;
              case 'file-cancel':
                  if (receivingFile.id === message.id) {
                      log(`File transfer for ${receivingFile.name} cancelled by peer.`, 'system');
                      receivingFile = {}; // Clear receiving state
                      document.getElementById('progressContainer').style.display = 'none';
                      document.getElementById('cancelFileBtn').classList.add('hidden'); // Hide cancel button
                  }
                  break;
              case 'webrtc-signal': // Handle WebRTC signals
                  handleWebRTCSignal(message.signalData);
                  break;
              case 'call-rejected':
                  log('Your call was rejected by the peer.', 'system');
                  hangUp(); // Reset local call state
                  break;
              case 'call-ended':
                  log('The call was ended by the peer.', 'system');
                  hangUp(); // Reset local call state
                  break;
          }
        } catch(e) { console.error(e); log('Failed to process message.', 'system'); }
      });
    }

    async function sendPacket(message) { 
        if (!peer || !peer.connected) { log('Not connected.', 'system'); return false; } 
        if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); } 
        try { 
            peer.send(await encrypt(JSON.stringify(message))); 
            return true; 
        } catch (err) { 
            console.error("Send failed:", err); 
            log(`Failed to send packet.`, 'system'); 
            return false; 
        } 
    }
    async function sendMessage() { 
        const msgInput = document.getElementById('message');
        if (!msgInput.value.trim()) return; // Prevent sending empty messages

        const messageContent = msgInput.value.replace(/\n/g, '<br>');
        const isViewOnce = document.getElementById('viewOnce').checked;
        const messageId = `msg-${Date.now()}`;
        const messageType = isViewOnce ? 'view-once-text' : 'text';

        if (await sendPacket({ type: messageType, content: messageContent, id: messageId })) {
            if (!isViewOnce) {
                const sentHTML = `${messageContent} <button onclick="deleteMessage('${messageId}')" class="text-xs font-bold text-red-500 hover:underline ml-2 opacity-50 hover:opacity-100">[X]</button>`;
                log(sentHTML, 'sent', messageId);
            } else {
                log(`<i>Sent a 'view-once' message.</i>`, 'sent', messageId); 
            }
            msgInput.value = ''; 
            msgInput.style.height = 'auto';
            document.getElementById('viewOnce').checked = false;
        } 
    }

    // --- VIEW-ONCE, DELETE & FULLSCREEN ---
    function revealOnceText(element, encodedContent) { 
        element.innerHTML = JSON.parse(atob(encodedContent));
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
        setTimeout(() => element.parentElement.remove(), 8000); 
    }
    
    function revealOnceMedia(element, blobId) {
        const blobInfo = viewOnceBlobs[blobId];
        if (!blobInfo) return;
        if (blobInfo.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = blobInfo.url;
            img.className = "max-w-xs rounded-lg";
            img.alt = "View-once Image";
            img.oncontextmenu = () => false; // Prevent right-click save
            element.innerHTML = '';
            element.appendChild(img);
            setTimeout(() => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            }, 5000);
        } else if (blobInfo.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = blobInfo.url;
            video.autoplay = true;
            video.className = "max-w-xs rounded-lg";
            video.oncontextmenu = () => false; // Prevent right-click save
            video.onended = () => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            };
            element.innerHTML = '';
            element.appendChild(video);
        }
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
    }
    function showFullscreenImage(src) { document.getElementById('fullscreen-image').src = src; document.getElementById('fullscreen-viewer').classList.remove('hidden'); }
    function hideFullscreenImage() { document.getElementById('fullscreen-viewer').classList.add('hidden'); }

    async function deleteMessage(messageId) {
        // Find and remove from chatMessages array first
        chatMessages = chatMessages.filter(msg => msg.id !== messageId);
        saveMessages();

        if (await sendPacket({ type: 'delete', id: messageId })) {
            const msgElementToRemove = document.getElementById(messageId);
            if (msgElementToRemove) {
                msgElementToRemove.remove(); 
            }
        }
    }

    // --- FILE TRANSFER ---
    async function handleFileChunk(message) {
      if (receivingFile.id !== message.id) return;
      const chunk = Uint8Array.from(atob(message.chunk), c => c.charCodeAt(0));
      receivingFile.chunks[message.index] = chunk; receivingFile.receivedSize += chunk.byteLength;
      document.getElementById('progressBar').style.width = `${(receivingFile.receivedSize / receivingFile.size) * 100}%`;
      await sendPacket({ type: 'file-ack', id: message.id, index: message.index });
      if (receivingFile.receivedSize === receivingFile.size) {
          const fileBlob = new Blob(receivingFile.chunks, {type: receivingFile.fileType});
          if (receivingFile.isViewOnce) {
              const blobId = `blob-${Date.now()}`;
              viewOnceBlobs[blobId] = { url: URL.createObjectURL(fileBlob), type: receivingFile.fileType, name: receivingFile.name };
              const mediaIcon = receivingFile.fileType.startsWith('image/') ? '🖼️' : '🎬';
              const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceMedia(this, '${blobId}')"><p class="font-bold">${mediaIcon} View-Once Media</p><p class="text-xs>${receivingFile.name} - Click to reveal</p></div>`;
              log(placeholderHTML, 'received', receivingFile.id); 
          } else {
              const url = URL.createObjectURL(fileBlob);
              let mediaHTML = '';
              if (receivingFile.fileType.startsWith('image/')) {
                  mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Received Image" onclick="showFullscreenImage(this.src)">`;
              } else if (receivingFile.fileType.startsWith('video/')) {
                  mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
              }
              const downloadUI = `<div class="mt-2 p-2 bg-gray-100 dark:bg-gray-600 rounded-lg flex items-center justify-between"><div class="text-sm"><strong>${receivingFile.name}</strong></div><a href="${url}" download="${receivingFile.name}" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-500"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg></a></div>`;
              log(mediaHTML + downloadUI, 'received', receivingFile.id); 
          }
          receivingFile = {};
          setTimeout(() => { 
            document.getElementById('progressContainer').style.display = 'none'; 
            document.getElementById('cancelFileBtn').classList.add('hidden'); 
          }, 2000);
      }
    }

    function prepareFile(event) { 
        const file = event.target.files[0];
        if (!file) return;
        if (sendingFile.id) { log('A file transfer is already in progress.', 'system'); return; }
        
        const isViewOnce = document.getElementById('viewOnce').checked;
        const fileId = `file-${Date.now()}`;
        
        log(`Preparing to send: <strong>${file.name}</strong>...`, 'system', fileId);
        document.getElementById('progressContainer').style.display = 'flex'; 
        document.getElementById('cancelFileBtn').classList.remove('hidden'); 
        document.getElementById('progressLabel').textContent = `Sending ${file.name}...`;
        document.getElementById('progressBar').style.width = '0%';

        fileReader = new FileReader(); 
        fileReader.onload = async (e) => {
            sendingFile = { 
                id: fileId, name: file.name, type: file.type, size: file.size, isViewOnce, 
                chunks: [], buffer: e.target.result, currentIndex: 0, lastAck: -1 
            };
            for (let i = 0; i < e.target.result.byteLength; i += CHUNK_SIZE) {
                sendingFile.chunks.push(e.target.result.slice(i, i + CHUNK_SIZE));
            }
            if(await sendPacket({ type: 'file-meta', id: fileId, name: file.name, size: file.size, fileType: file.type, isViewOnce })) {
                sendChunk();
                document.getElementById('viewOnce').checked = false;
            } else { 
                log(`Could not initiate file transfer.`, 'system'); 
                cancelFileTransfer(false); 
            }
        };
        fileReader.onerror = (e) => {
            console.error("FileReader error:", e);
            log("Error reading file for transfer.", "system");
            cancelFileTransfer(false);
        };
        fileReader.readAsArrayBuffer(file); 
        event.target.value = null; 
    }

    function sendChunk() {
        if (!sendingFile.id || sendingFile.currentIndex > sendingFile.lastAck + 1) return;
        if (sendingFile.currentIndex >= sendingFile.chunks.length) {
            if (!sendingFile.isViewOnce) {
                const fileBlob = new Blob([sendingFile.buffer], {type: sendingFile.type});
                const url = URL.createObjectURL(fileBlob);
                let mediaHTML = '';
                if (sendingFile.type.startsWith('image/')) {
                    mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Sent Image" onclick="showFullscreenImage(this.src)">`;
                } else if (sendingFile.type.startsWith('video/')) {
                    mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
                }
                log(mediaHTML, 'sent', sendingFile.id); 
            } else {
                log(`<i>Sent a 'view-once' file.</i>`, 'sent', sendingFile.id); 
            }
            setTimeout(() => { 
                document.getElementById('progressContainer').style.display = 'none'; 
                document.getElementById('cancelFileBtn').classList.add('hidden'); 
            }, 2000);
            sendingFile = {}; 
            return;
        }
        const chunk = sendingFile.chunks[sendingFile.currentIndex];
        const base64Chunk = btoa(new Uint8Array(chunk).reduce((data, byte) => data + String.fromCharCode(byte), ''));
        sendPacket({ type: 'file-chunk', id: sendingFile.id, index: sendingFile.currentIndex, chunk: base64Chunk }).then(sent => {
            if (sent) {
                sendingFile.ackTimeout = setTimeout(() => { log(`No ACK for chunk ${sendingFile.currentIndex}, retrying...`, 'system'); sendChunk(); }, 10000);
                document.getElementById('progressBar').style.width = `${((sendingFile.currentIndex + 1) / sendingFile.chunks.length) * 100}%`;
                if (sendingFile.currentIndex === sendingFile.lastAck + 1) sendingFile.currentIndex++;
            } else { 
                log(`Critical send failure for chunk ${sendingFile.currentIndex}. Aborting transfer.`, 'system'); 
                clearTimeout(sendingFile.ackTimeout); 
                cancelFileTransfer(false); 
            }
        });
    }

    function cancelFileTransfer(shouldNotifyPeer) {
        if (fileReader) {
            fileReader.abort(); 
            fileReader = null;
        }
        if (sendingFile.id && shouldNotifyPeer) {
            sendPacket({ type: 'file-cancel', id: sendingFile.id });
            log(`File transfer for ${sendingFile.name} cancelled.`, 'system');
        } else if (receivingFile.id && shouldNotifyPeer) {
             // This branch handles a local cancel of a *receiving* file, which isn't directly exposed by a button but is here for completeness.
            sendPacket({ type: 'file-cancel', id: receivingFile.id }); // Tell sender we cancelled
            log(`Receiving file transfer for ${receivingFile.name} cancelled.`, 'system');
        }
        
        clearTimeout(sendingFile.ackTimeout); 
        sendingFile = {}; 
        receivingFile = {}; 

        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('cancelFileBtn').classList.add('hidden'); 
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressLabel').textContent = '';
    }

    // --- WebRTC CALLING LOGIC (merged with data channel) ---
    function updateVideoCallButtonsState() {
        const isPeerConnected = peer && peer.connected;
        const inCall = !!rtcPeerConnection; // True if rtcPeerConnection exists
        const isIncomingCall = !incomingCallNotification.classList.contains('hidden');

        // Hide notification if it's not an incoming call anymore
        if (!isIncomingCall && incomingCallNotification.style.display !== 'none') {
            incomingCallNotification.classList.add('hidden');
        }

        // Main call button inside video container
        // Visible if no call is in progress/incoming, and peer is connected
        callButton.disabled = !isPeerConnected || inCall || isIncomingCall;
        callButton.style.display = (inCall || isIncomingCall) ? 'none' : ''; // Hide if call is active or incoming

        // Hangup button
        // Visible if a call is in progress/incoming
        hangupButton.disabled = !isPeerConnected || (!inCall && !isIncomingCall); // Enabled if call exists or is incoming AND peer is connected
        hangupButton.style.display = (inCall || isIncomingCall) ? '' : 'none'; // Show if call is active or incoming

        // Accept/Reject buttons for incoming call notification
        if (isIncomingCall) {
            acceptCallButton.style.display = '';
            rejectCallButton.style.display = '';
            acceptCallButton.disabled = !isPeerConnected;
            rejectCallButton.disabled = !isPeerConnected;
        } else {
            acceptCallButton.style.display = 'none';
            rejectCallButton.style.display = 'none';
        }

        // Update status text based on state
        if (!isPeerConnected) {
            statusDiv.textContent = 'Not connected to peer chat.';
        } else if (!localStream && !inCall && !isIncomingCall) { // Added !inCall and !isIncomingCall
            statusDiv.textContent = 'Camera Off. Ready to start call.';
        } else if (isIncomingCall) {
            statusDiv.textContent = 'Incoming Call...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'new') {
            statusDiv.textContent = 'Initiating call...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'connecting') {
            statusDiv.textContent = 'Connecting...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'connected') {
            statusDiv.textContent = 'Call Connected!';
            statusDiv.style.display = 'none'; // Hide status once connected
        } else if (rtcPeerConnection && ['disconnected', 'closed', 'failed'].includes(rtcPeerConnection.connectionState)) {
             statusDiv.textContent = 'Call ended.';
             statusDiv.style.display = 'block'; // Show status temporarily
        } else if (localStream && !inCall && !isIncomingCall) { // Added this for when camera is on but no call
             statusDiv.textContent = 'Camera On. Ready to start call.';
        } else {
            statusDiv.textContent = 'Ready to start call.'; // Fallback
        }
    }


    const setupPeerConnection = (isInitiator) => {
        rtcPeerConnection = new RTCPeerConnection(servers);
        
        // Add local stream tracks only if available (will be available from startOrToggleCallUI or acceptCallButton)
        if (localStream) {
            localStream.getTracks().forEach(track => rtcPeerConnection.addTrack(track, localStream));
        }

        rtcPeerConnection.ontrack = event => {
            const [remoteStream] = event.streams;
            remoteVideo.srcObject = remoteStream;
            statusDiv.style.display = 'none'; // Hide status once video starts
        };

        rtcPeerConnection.onicecandidate = event => {
            if (event.candidate) {
                sendPacket({ type: 'webrtc-signal', signalData: { type: 'candidate', candidate: event.candidate } });
            }
        };

        rtcPeerConnection.onnegotiationneeded = async () => {
            if (isInitiator) {
                try {
                    const offer = await rtcPeerConnection.createOffer();
                    await rtcPeerConnection.setLocalDescription(offer);
                    sendPacket({ type: 'webrtc-signal', signalData: { type: 'offer', sdp: rtcPeerConnection.localDescription } });
                    statusDiv.textContent = "Sending call offer. Waiting for peer to accept...";
                } catch (e) {
                    console.error("Error creating offer:", e);
                    statusDiv.textContent = "Error creating call offer.";
                    hangUp();
                }
            }
        };

        rtcPeerConnection.onconnectionstatechange = () => {
            console.log("RTC connection state:", rtcPeerConnection.connectionState);
            if (rtcPeerConnection.connectionState === 'connected') {
                statusDiv.textContent = 'Call Connected!';
                statusDiv.style.display = 'block';
                setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
                updateVideoCallButtonsState(); // Update buttons immediately
            } else if (['disconnected', 'closed', 'failed'].includes(rtcPeerConnection.connectionState)) {
                hangUp(); // Call hangUp if connection fails/closes
            }
        };
        updateVideoCallButtonsState(); // Update buttons after PC setup
    };

    // New primary call button inside video container
    callButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }
        if (rtcPeerConnection) {
            log('A call is already active or being attempted.', 'system');
            return;
        }

        try {
            statusDiv.textContent = "Requesting camera access...";
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            statusDiv.textContent = "Camera on. Initiating call...";
            setupPeerConnection(true); // True indicates this peer is the initiator
            // Offer creation and sending happens inside onnegotiationneeded
        } catch (error) {
            console.error("Error accessing media devices.", error);
            alert("Could not access your camera. Please grant permissions or ensure no other app is using it.");
            statusDiv.textContent = "Error: Camera access denied.";
            hangUp(); // Clean up any partial state
        } finally {
            updateVideoCallButtonsState();
        }
    };


    acceptCallButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }
        if (!incomingCallOffer) {
            console.error("No incoming offer to accept.");
            return;
        }

        incomingCallNotification.classList.add('hidden'); // Hide notification
        statusDiv.textContent = "Accepting call...";
        videoCallContainer.classList.remove('hidden'); // Ensure video container is visible

        try {
            // Get local stream if not already active
            if (!localStream) {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                statusDiv.textContent = "Camera on. Connecting...";
            }
            
            if (!rtcPeerConnection) {
                setupPeerConnection(false); // Set up as answerer if not already
            } else {
                // If rtcPeerConnection exists but it was from a previous attempt (e.g. initiator failed)
                // we should re-add tracks if they changed, or ensure it's ready.
                // For simplicity, if PC exists, assume it's ready for remote description.
                // If the PC was already initialized as initiator and then failed, hangUp() should have reset it.
            }

            // Ensure localStream tracks are added *after* localStream is guaranteed to exist
            // This is handled in setupPeerConnection, but if localStream was just acquired here,
            // we might need to add tracks manually if setupPeerConnection was called *before* localStream was ready.
            // Best practice: always call setupPeerConnection *after* localStream is ready for a new call.
            // The current setupPeerConnection checks for localStream and adds. This is fine.
            
            await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(incomingCallOffer));
            const answer = await rtcPeerConnection.createAnswer();
            await rtcPeerConnection.setLocalDescription(answer);
            sendPacket({ type: 'webrtc-signal', signalData: { type: 'answer', sdp: rtcPeerConnection.localDescription } });
            statusDiv.textContent = "Sending call answer...";
        } catch (e) {
            console.error("Error accepting call:", e);
            alert("Failed to accept call. Check camera permissions.");
            statusDiv.textContent = "Error accepting call.";
            hangUp(); // Clean up if acceptance fails
        } finally {
            incomingCallOffer = null; // Clear the stored offer
            updateVideoCallButtonsState();
        }
    };

    rejectCallButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Main chat connection not established.");
            return;
        }
        incomingCallNotification.classList.add('hidden'); // Hide notification
        statusDiv.textContent = "Call Rejected.";
        sendPacket({ type: 'call-rejected' }); // Notify initiator
        incomingCallOffer = null; // Clear stored offer
        hangUp(); // Reset call state locally
    };


    async function handleWebRTCSignal(signalData) {
        if (signalData.type === 'offer') {
            if (rtcPeerConnection && rtcPeerConnection.connectionState !== 'closed' && rtcPeerConnection.connectionState !== 'new') {
                console.warn("Already in a call or call setup. Ignoring new offer.");
                // Optionally send a busy signal back
                return;
            }
            
            // Show incoming call notification
            incomingCallOffer = signalData.sdp; // Store the offer
            incomingCallNotification.classList.remove('hidden'); // Show notification
            statusDiv.textContent = "Incoming Call...";
            log('Incoming video call. Click Accept or Reject.', 'system');
            updateVideoCallButtonsState(); // Update buttons for incoming call

        } else if (signalData.type === 'answer') {
            if (rtcPeerConnection && rtcPeerConnection.localDescription.type === 'offer') {
                try {
                    await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    statusDiv.textContent = "Call established!";
                } catch (e) {
                    console.error("Error setting remote answer:", e);
                    statusDiv.textContent = "Error during call setup.";
                    hangUp();
                }
            } else {
                console.warn("Received answer but not expecting one or RTCPeerConnection not initialized as initiator.", signalData);
            }
        } else if (signalData.type === 'candidate') {
            if (rtcPeerConnection) {
                try {
                    await rtcPeerConnection.addIceCandidate(new RTCIceCandidate(signalData.candidate));
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                }
            } else {
                console.warn("Received ICE candidate but RTCPeerConnection is not initialized.", signalData);
            }
        }
    }

    function hangUp() {
        if (rtcPeerConnection) {
            // Notify peer that call is ending
            if (peer && peer.connected) {
                sendPacket({ type: 'call-ended' });
            }
            rtcPeerConnection.close();
            rtcPeerConnection = null;
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        
        incomingCallNotification.classList.add('hidden'); // Ensure notification is hidden
        incomingCallOffer = null; // Clear any pending offer
        
        // This is the crucial line to hide the video UI and return to chat
        videoCallContainer.classList.add('hidden'); 
        
        updateVideoCallButtonsState(); // Re-enable start camera, disable offer/answer
    }

    hangupButton.onclick = hangUp;

    // Auto-resize textarea
    document.getElementById('message').addEventListener('input', (e) => { e.target.style.height = 'auto'; e.target.style.height = (e.target.scrollHeight) + 'px'; });

    // Initial load of theme and persisted connection data
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme && themes.includes(savedTheme)) {
            document.body.classList.add(savedTheme);
            currentThemeIndex = themes.indexOf(savedTheme);
        } else {
            // Default to 'light' if no theme saved or invalid theme
            document.body.classList.add('light');
            localStorage.setItem('theme', 'light');
            currentThemeIndex = 0;
        }

        const savedKey = localStorage.getItem('sharedKey');
        const savedSignal = localStorage.getItem('localSignal');

        if (savedKey) {
            document.getElementById('sharedKey').value = savedKey;
        }
        if (savedSignal) {
            document.getElementById('signalOut').value = savedSignal;
        }
        
        // If there's a stored key or signal, we can make the connect button more prominent
        // Or provide a hint to the user.
        if (savedKey || savedSignal) {
            logToSetup('Connection details found. Enter peer\'s signal to reconnect, or click "Start New Connection".');
        }
        // Initially disable video call buttons until peer connection is established
        updateVideoCallButtonsState();
    });

  </script>
</body>
</html>
