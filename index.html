<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encrypted P2P Chat & Call</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Base Chat Backgrounds & General Colors */
    body.light { background-color: #f0f0f0; color: #212121; } /* Changed text color to a darker shade */
    body.dark { background-color: #1a1a1a; color: #eee; }
    body.theme-3 { background-color: #e0f2f7; color: #212121; } /* Light blue */
    body.theme-4 { background-color: #f0fff4; color: #222; } /* Light green */

    /* Chat Box Backgrounds */
    body.light .chat-bg {
      background-color: #e5ddd5;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 800 800"><g fill="%23cbc5bd" fill-opacity="0.4"><path d="M0 0h800v800H0z"/><path d="M283.25 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V100c0-55.25-44.75-100-100-100zM0 283.25c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm583.25-100c55.25 0 100 44.75 100 100v100h-200V183.25c0-55.25 44.75-100 100-100zM0 516.75c0-55.25 44.75-100 100-100h100v200H100c-55.25 0-100-44.75-100-100zm283.25 100c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm233.5 0c-55.25 0-100 44.75-100 100v100h200V616.75c0-55.25-44.75-100-100-100zm266.5-100c55.25 0 100 44.75 100 100v100h-200V516.75c0-55.25 44.75-100 100-100z"/></g></svg>');
    }
    body.dark .chat-bg { background-color: #0d1418; }
    body.theme-3 .chat-bg { background-color: #bbdefb; } /* Lighter blue for chat background */
    body.theme-4 .chat-bg { background-color: #c8e6c9; } /* Lighter green for chat background */

    /* Custom Background (will override chat-bg for image) */
    #chatBox.has-custom-bg {
        background-color: transparent !important; /* Allow image to show through */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }


    /* Header/Footer Backgrounds */
    body.light header, body.light footer { background-color: #f0f0f0; }
    body.dark header, body.dark footer { background-color: #1f2c34; }
    body.theme-3 header, body.theme-3 footer { background-color: #81d4fa; } /* Bright blue */
    body.theme-4 header, body.theme-4 footer { background-color: #a5d6a7; } /* Muted green */

    /* Header/Footer Text Colors */
    body.light header, body.light header h2, body.light header button { color: #212121; }
    body.dark header, body.dark header h2, body.dark header button { color: #ffffff; }
    body.theme-3 header, body.theme-3 header h2, body.theme-3 header button { color: #01579B; } /* Dark blue for theme-3 header text */
    body.theme-4 header, body.theme-4 header h2, body.theme-4 header button { color: #1B5E20; } /* Dark green for theme-4 header text */

    /* Input/Textarea Backgrounds */
    body.light input, body.light textarea { background-color: #fff; border-color: #ddd; color: #212121; } /* Changed text color to a darker shade */
    body.dark input, body.dark textarea { background-color: #2a3942; border-color: #555; color: #eee; }
    body.theme-3 input, body.theme-3 textarea { background-color: #e3f2fd; border-color: #90caf9; color: #212121; }
    body.theme-4 input, body.theme-4 textarea { background-color: #e8f5e9; border-color: #a5d6a7; color: #222; }
    
    /* Sent Bubbles */
    .sent-bubble { background-color: #dcf8c6; color: #212121; } /* Changed text color to a darker shade */
    .dark .sent-bubble { background-color: #056162; color: #eee; } /* Default dark green */
    .theme-3 .sent-bubble { background-color: #4fc3f7; color: #fff; } /* Blue for sent */
    .theme-4 .sent-bubble { background-color: #66bb6a; color: #fff; } /* Green for sent */

    /* Received Bubbles */
    .received-bubble { background-color: #ffffff; color: #212121; } /* Changed text color to a darker shade */
    .dark .received-bubble { background-color: #2a3942; color: #eee; } /* Default dark grey */
    .theme-3 .received-bubble { background-color: #e1f5fe; color: #212121; } /* Light blue for received */
    body.theme-4 .received-bubble { background-color: #f1f8e9; color: #222; } /* Light yellow-green for received */


    /* Tail for Bubbles */
    .message-bubble:after {
        content: ''; position: absolute; top: 0; width: 0; height: 0; border: 10px solid transparent;
    }
    .sent-bubble:after { right: -10px; }
    .received-bubble:after { left: -10px; }

    /* Tail colors based on theme */
    .light .sent-bubble:after { border-left-color: #dcf8c6; }
    .dark .sent-bubble:after { border-left-color: #056162; }
    .theme-3 .sent-bubble:after { border-left-color: #4fc3f7; }
    .theme-4 .sent-bubble:after { border-left-color: #66bb6a; }

    .light .received-bubble:after { border-right-color: #ffffff; }
    .dark .received-bubble:after { border-right-color: #2a3942; }
    .theme-3 .received-bubble:after { border-right-color: #e1f5fe; }
    .theme-4 .received-bubble:after { border-right-color: #f1f8e9; }


    /* Scrollbar */
    #chatBox::-webkit-scrollbar { width: 6px; }
    #chatBox::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
    body.dark #chatBox::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }
  
    /* Make video-call-container full screen overlay */
    #video-call-container {
        position: fixed; /* Make it an overlay */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 50; /* Ensure it's above the chat but below notification */
        display: flex; /* Always flex, hide with 'hidden' class */
        flex-direction: column;
        background-color: rgba(0, 0, 0, 0.9); /* Slightly transparent dark background */
        color: white;
    }

    #video-call-container.hidden {
        display: none;
    }

    /* Style for the video elements to fill space */
    #video-call-container .flex-grow { /* This targets the div containing local and remote video */
        position: relative; /* For absolute positioning of inner videos */
        width: 100%;
        height: 100%;
        display: flex; /* Use flex to align status text */
        align-items: center;
        justify-content: center;
        overflow: hidden; /* Hide anything outside video boundaries */
    }

    /* Remote Video (main view) */
    #remoteVideoContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #1f2937; /* Dark background for empty video area */
    }
    #remoteVideo {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Fill the container, cropping if necessary */
    }

    /* Local Video (small overlay) */
    #localVideoContainer {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        width: 120px; /* Smaller size */
        height: 90px;
        z-index: 60; /* Above remote video */
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5);
        transform: scaleX(-1); /* Mirror local video */
        background-color: #1f2937; /* Dark background for empty video area */
    }
    #localVideo {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Fill the container */
    }

    #status {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        font-size: 1.5rem;
        z-index: 65; /* Above videos, below local video overlay */
    }

    /* Controls container at the bottom */
    #video-controls {
        display: flex;
        justify-content: center;
        padding: 1rem;
        background-color: rgba(0,0,0,0.6); /* Semi-transparent background for controls */
        z-index: 70;
    }

    /* Incoming Call Notification */
    #incoming-call-notification {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 30px;
        border-radius: 15px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    #incoming-call-notification h3 {
        font-size: 2rem;
        margin-bottom: 20px;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    /* Sticker Picker Styles */
    #stickerPicker {
        position: absolute;
        bottom: 80px; /* Above the footer input */
        right: 10px;
        width: 300px;
        max-height: 400px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        overflow-y: auto;
        z-index: 20; /* Above chat but below modals */
        display: none; /* Hidden by default */
        flex-direction: column;
        padding: 1rem;
    }
    body.dark #stickerPicker {
        background-color: #2a3942;
        color: #eee;
    }

    #stickerPicker .section-title {
        font-weight: bold;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.25rem;
    }
    body.dark #stickerPicker .section-title {
        border-bottom-color: #555;
    }

    #stickerPicker .sticker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
        gap: 0.5rem;
        padding: 0.5rem 0;
    }

    #stickerPicker .sticker-item {
        font-size: 1.8rem;
        text-align: center;
        cursor: pointer;
        padding: 0.2rem;
        border-radius: 4px;
        transition: background-color 0.2s;
        position: relative; /* For the remove button */
    }
    #stickerPicker .sticker-item:hover {
        background-color: #e0e0e0;
    }
    body.dark #stickerPicker .sticker-item:hover {
        background-color: #4a5962;
    }

    .sticker-item-save-btn {
        font-size: 0.7rem;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 2px 5px;
        border-radius: 3px;
        cursor: pointer;
        margin-left: 5px;
        display: inline-block;
    }
    .sticker-item-save-btn:hover {
        background-color: #45a049;
    }

    .sticker-message {
        font-size: 2.5rem; /* Larger font size for sent/received emoji stickers */
        text-align: center;
        padding: 5px;
    }

    .sticker-message img {
        max-width: 100px; /* Max size for received image stickers */
        height: auto;
        display: block;
        margin: 0 auto;
    }

    .sticker-item img {
        width: 40px; /* Size for image previews in picker */
        height: 40px;
        object-fit: contain;
    }

    .sticker-item .remove-btn {
        position: absolute;
        top: -5px; /* Adjust as needed */
        right: -5px; /* Adjust as needed */
        background-color: rgba(255, 0, 0, 0.7);
        color: white;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        font-size: 0.7rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 10;
    }
    .sticker-item:hover .remove-btn {
        opacity: 1;
    }

    /* Styles for Reply and Delete action buttons */
    .message-bubble {
        position: relative;
    }
    .message-actions {
        position: absolute;
        bottom: 2px;
        right: 5px;
        display: flex;
        align-items: center;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 5;
    }
    .message-bubble:hover .message-actions {
        opacity: 1;
    }
    .action-button {
        background-color: rgba(0, 0, 0, 0.1);
        color: inherit;
        border-radius: 50%;
        width: 22px;
        height: 22px;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: none;
    }
    .dark .action-button {
        background-color: rgba(255, 255, 255, 0.15);
    }
    .action-button.delete-btn {
        font-size: 0.9rem; /* Make '√ó' slightly larger for better visibility */
    }

    .reply-preview {
        background-color: #f0f0f0;
        border-left: 4px solid #4CAF50; /* Green border for reply */
        padding: 8px 12px;
        border-radius: 8px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .dark .reply-preview {
        background-color: #333;
        border-left-color: #4CAF50;
    }
    .reply-preview .content {
        max-width: calc(100% - 30px); /* Space for cancel button */
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        font-size: 0.9rem;
        color: #555;
        /* Flex properties to align thumbnail and text */
        display: flex;
        align-items: center;
    }
    .dark .reply-preview .content {
        color: #bbb;
    }
    .reply-preview .cancel-btn {
        background: none;
        border: none;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        color: #888;
        padding: 0 4px;
    }
    .dark .reply-preview .cancel-btn {
        color: #bbb;
    }

    .replied-message-content {
        border-left: 3px solid #ccc; /* Light border for the quoted message */
        padding-left: 8px;
        margin-bottom: 4px;
        font-size: 0.85em;
        opacity: 0.8;
        cursor: pointer;
    }
    .dark .replied-message-content {
        border-left-color: #666;
    }

    /* MODIFICATION: Voice Message Styles */
    #recordButton.recording {
        color: #ef4444; /* Red color when recording */
        animation: pulse-red 1.5s infinite;
    }
    @keyframes pulse-red {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    .voice-message-player {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 250px;
    }
    .voice-message-player audio {
        width: 100%;
        height: 30px;
    }
  </style>
</head>
<body>

  <div id="app" class="h-screen w-screen flex flex-col hidden">
    <header class="p-3 flex items-center justify-between shadow-sm z-10">
      <div class="flex items-center space-x-2">
          <h2 class="text-lg font-medium">Encrypted P2P Chat</h2>
          <span id="peerStatus" class="text-sm font-semibold text-gray-500 flex items-center">
              <span class="h-2 w-2 bg-gray-500 rounded-full mr-1"></span>Offline
          </span>
      </div>
      <div class="flex items-center space-x-2">
          <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h1M3 12H2m8.006-7.5l-.574-.574m-9.454 9.454l-.574-.574M19 12a7 7 0 11-14 0 7 7 0 0114 0zm-9.146 5.146l.574.574m9.454-9.454l-.574-.574" />
              </svg>
          </button>
          <input type="file" id="bgImageInput" accept="image/*" class="hidden" onchange="changeChatBackground(event)" />
          <label for="bgImageInput" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium cursor-pointer" title="Change chat background">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
          </label>
          <button onclick="clearChatBackground()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium" title="Clear custom background">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
              </svg>
          </button>
          <button onclick="startOrToggleCallUI()" class="p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center text-sm font-medium">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
              </svg>
          </button>
      </div>
    </header>

    <main id="chatBox" class="flex-grow p-4 overflow-y-auto chat-bg"></main>

    <div id="progressContainer" class="px-4 pb-2 chat-bg flex items-center space-x-2" style="display: none;">
        <div class="flex-grow">
            <div class="text-sm text-gray-600 dark:text-gray-400 mb-1" id="progressLabel"></div>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
              <div id="progressBar" class="bg-green-500 h-2.5 rounded-full transition-all duration-150" style="width: 0%"></div>
            </div>
        </div>
        <button id="cancelFileBtn" onclick="cancelFileTransfer(true)" class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm hidden">Cancel</button>
    </div>
    
    <div id="stickerPicker" class="absolute hidden">
        <div class="flex justify-end">
            <button onclick="toggleStickerPicker()" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl font-bold">&times;</button>
        </div>

        <div class="section-title mt-4">Add Custom Sticker URL</div>
        <div class="flex items-center space-x-2 mt-2">
            <input type="url" id="customStickerUrlInput" placeholder="Paste sticker URL (gif/webp)" class="flex-grow p-2 rounded-md border focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
            <button onclick="addCustomStickerUrl()" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Add</button>
        </div>
        <div id="customStickerUrlError" class="text-red-500 text-sm mt-1 hidden"></div>
        <div class="flex justify-end mt-2">
             <button onclick="clearCustomStickers()" class="text-xs text-red-500 hover:underline">Clear My Custom Stickers</button>
        </div>

        <div class="section-title mt-4">All Stickers</div>
        <div id="allStickersGrid" class="sticker-grid"></div>
    </div>

    <footer class="p-2 flex flex-col space-y-2 relative">
        <!-- MODIFICATION: Added recording status indicator -->
        <div id="recordingIndicator" class="hidden items-center justify-center p-2">
            <span class="h-3 w-3 bg-red-500 rounded-full animate-pulse mr-2"></span>
            <span id="recordingTimer" class="text-sm text-gray-600 dark:text-gray-400">00:00</span>
        </div>

        <!-- Reply Preview Section -->
        <div id="replyPreview" class="reply-preview hidden">
            <div class="content flex-grow">
                Replying to: <span id="replyContentSnippet" class="font-semibold text-gray-800 dark:text-gray-200"></span>
            </div>
            <button class="cancel-btn" onclick="cancelReply()">&times;</button>
        </div>

        <div class="flex items-center space-x-2">
            <label class="flex items-center space-x-1 cursor-pointer p-2 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600" title="Send as a view-once message or file">
                <input type="checkbox" id="viewOnce" class="form-checkbox h-4 w-4 text-green-600 bg-gray-100 dark:bg-gray-900 border-gray-300 dark:border-gray-600 rounded focus:ring-green-500">
                <span class="text-xs text-gray-500">View Once</span>
            </label>
            <input type="file" id="mediaInput" onchange="queueFilesForSending(event)" class="hidden" multiple />
            <label for="mediaInput" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>
            </label>
            <button onclick="toggleStickerPicker()" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>
            <textarea id="message" placeholder="Type a message" class="flex-grow p-2 rounded-full border focus:outline-none focus:ring-2 focus:ring-green-500" rows="1" onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"></textarea>
            
            <!-- MODIFICATION: Added microphone button for voice messages -->
            <button id="recordButton" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600" title="Record Voice Message">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0a5 5 0 01-4.52 4.97A5.002 5.002 0 015 8a1 1 0 00-2 0a7.001 7.001 0 006 6.93V17H7a1 1 0 100 2h6a1 1 0 100-2h-2v-2.07z" clip-rule="evenodd" />
                </svg>
            </button>
            <button onclick="sendMessage()" class="p-2 rounded-full text-gray-500 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
            </button>
        </div>
    </footer>
  </div>

  <div id="video-call-container" class="hidden">
      <div class="flex-grow relative"> <div id="remoteVideoContainer" class="bg-gray-800 flex items-center justify-center rounded-lg overflow-hidden">
              <video id="remoteVideo" autoplay playsinline class="w-full h-full"></video>
              <div id="status" class="absolute text-gray-400 p-4 text-center">Waiting to connect...</div>
          </div>
          <div id="localVideoContainer" class="rounded-lg shadow-lg">
              <video id="localVideo" autoplay playsinline muted class="w-full h-full"></video>
          </div>
      </div>

      <div id="video-controls" class="pt-2"> 
          <button id="callButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-full transition-colors text-lg disabled:opacity-50 mx-2" disabled>Start Call</button>
          <button id="hangupButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-full transition-colors text-lg disabled:opacity-50 mx-2" disabled>Hang Up</button>
          <button id="switchCameraButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full transition-colors text-lg disabled:opacity-50 mx-2" disabled>Switch Camera</button>
      </div>
  </div>

  <div id="incoming-call-notification" class="hidden">
      <h3>Incoming Video Call!</h3>
      <p class="mb-4">From your peer</p>
      <div class="flex justify-center space-x-4">
          <button id="acceptCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full text-lg">Accept</button>
          <button id="rejectCallButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full text-lg">Reject</button>
      </div>
  </div>

  <div id="setup" class="min-h-screen bg-gray-100 dark:bg-gray-900 flex items-center justify-center p-4">
      <div class="max-w-xl w-full bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg space-y-4">
          <h2 class="text-2xl font-bold text-center text-gray-800 dark:text-gray-200">Setup Secure Connection</h2>
          <div><label class="font-bold text-gray-600 dark:text-gray-400">1. Enter a Shared Secret (Password)</label><input type="text" id="sharedKey" placeholder="Must match your peer's secret" oninput="checkStrength()" class="w-full mt-1 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded" /><div id="strengthMeter" class="text-sm mt-1"></div></div>
          <div class="grid md:grid-cols-2 gap-4">
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">2. Start & Share Your Signal</label><button onclick="startChat()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Start New Chat</button><textarea id="signalOut" placeholder="Your signal data appears here..." class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="copySignal()" class="w-full bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded">Copy Signal</button></div>
              <div class="space-y-2"><label class="font-bold text-gray-600 dark:text-gray-400">3. Paste Peer's Signal & Connect</label><textarea id="signalIn" placeholder="Paste peer's signal data here" class="w-full h-24 p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded"></textarea><button onclick="connect()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Connect</button></div>
          </div>
          <button onclick="newConnection()" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded mt-4">Start New Connection</button>
          <div id="log" class="text-center text-sm text-gray-500 dark:text-gray-400"></div>
      </div>
  </div>
  
  <div id="fullscreen-viewer" onclick="hideFullscreenImage()" class="hidden fixed inset-0 bg-black bg-opacity-80 z-40 flex items-center justify-center p-4 cursor-pointer">
      <img id="fullscreen-image" src="" class="max-w-full max-h-full">
      <button onclick="hideFullscreenImage()" class="absolute top-5 right-5 text-white text-4xl font-bold">&times;</button>
  </div>

  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script>
    let peer, aesKey;
    let receivingFile = {}, sendingFile = {};
    // New variables for image sticker transfer
    let sendingImageSticker = {};
    let receivingImageSticker = {};

    let viewOnceBlobs = {};
    let chatMessages = []; // Array to store message objects for current session
    const MAX_MESSAGES = 100; // Limit for messages in current session
    const CHUNK_SIZE = 64 * 1024; // 64 KB for file chunks and image sticker chunks
    let fileReader = null; // Reference to FileReader for cancellation
    let fileSendQueue = [];

    // MODIFICATION: Voice Message variables
    let mediaRecorder;
    let audioChunks = [];
    let recordingTimerInterval;

    // Define the themes and their names
    const themes = ['light', 'dark', 'theme-3', 'theme-4'];
    let currentThemeIndex = 0; // Default to first theme (light)

    // WebRTC elements and variables
    const servers = { iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };
    let rtcPeerConnection = null;
    let localStream = null;
    let incomingCallOffer = null; // To store the received offer until accepted/rejected
    
    const callButton = document.getElementById('callButton');
    const hangupButton = document.getElementById('hangupButton');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const statusDiv = document.getElementById('status');
    const videoCallContainer = document.getElementById('video-call-container');
    const incomingCallNotification = document.getElementById('incoming-call-notification');
    const acceptCallButton = document.getElementById('acceptCallButton');
    const rejectCallButton = document.getElementById('rejectCallButton');
    const peerStatusElement = document.getElementById('peerStatus');
    const chatBox = document.getElementById('chatBox');
    const switchCameraButton = document.getElementById('switchCameraButton');

    let availableCameras = [];
    let currentCameraIndex = 0;

    // Typing status variables
    let typingTimer;
    let peerTypingTimer;

    // Reply feature variables
    let currentReplyTo = null;
    const replyPreview = document.getElementById('replyPreview');
    const replyContentSnippet = document.getElementById('replyContentSnippet');

    // Sticker related variables
    const predefinedStickers = [
        { type: 'emoji', content: 'üòÄ' }, { type: 'emoji', content: 'üòÇ' }, { type: 'emoji', content: 'üëç' },
        { type: 'emoji', content: '‚ù§Ô∏è' }, { type: 'emoji', content: 'üëè' }, { type: 'emoji', content: 'ü•≥' },
        { type: 'emoji', content: 'ü§î' }, { type: 'emoji', content: 'üöÄ' }, { type: 'emoji', content: 'üåü' },
        { type: 'emoji', content: 'üí°' }, { type: 'emoji', content: 'üéâ' }, { type: 'emoji', content: 'üî•' },
        { type: 'emoji', content: 'üíØ' }, { type: 'emoji', content: 'üôè' }, { type: 'emoji', content: 'ü§Ø' },
        { type: 'image', content: 'https://media.tenor.com/oWTGv7XpHY4AAAAm/sseeyall-bubu-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/KNiXTCA36YYAAAAm/bubu-dudu-sseeyall.webp' },
        { type: 'image', content: 'https://media.tenor.com/BvlQdl0TAeIAAAAm/cute.webp' },
         { type: 'image', content: 'https://media.tenor.com/90xN7I6NjecAAAAm/bubu-dudu-sseeyall.webp' },
        { type: 'image', content: 'https://media.tenor.com/vJRHkcdlEQQAAAAm/casal-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/aMOxt0o16TQAAAAm/bubu-bubu-dudu.webp' },
         { type: 'image', content: 'https://media.tenor.com/F9Q3thp6tzUAAAAm/bubu-bubu-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/HOLG_hTN8WsAAAAm/bubu-jumping-on-dudu-happy.webp' },
        { type: 'image', content: 'https://media.tenor.com/I_rw0vcOXJYAAAAm/dudu-bubu-cute-kiss.webp' },
         { type: 'image', content: 'https://media.tenor.com/hoblaIrKqRgAAAAm/bubu-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/tW4jk2HaN3YAAAAm/bubu-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/uRyi-tc_AdAAAAAm/bubu-dudu.webp' },
         { type: 'image', content: 'https://media.tenor.com/PXKZhCEfEfsAAAAm/bubu-bubu-dudu.webp' },
        { type: 'image', content: 'https://media.tenor.com/qZTZ0zYcB9YAAAAm/bubu-dudu-sseeyall.webp' },
        { type: 'image', content: 'https://media.tenor.com/BKP6erkQWjMAAAAm/bubu-dudu-sseeyall.webp' },
    ];
    let userCustomStickers = [];
    const MAX_RECENT_STICKERS = 6;
    const CUSTOM_STICKERS_STORAGE_KEY = 'customStickers';
    const stickerPicker = document.getElementById('stickerPicker');
    const allStickersGrid = document.getElementById('allStickersGrid');
    const customStickerUrlInput = document.getElementById('customStickerUrlInput');
    const customStickerUrlError = document.getElementById('customStickerUrlError');


    // --- UTILITY & SETUP ---
    function toggleTheme() {
        document.body.classList.remove(...themes);
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        const newTheme = themes[currentThemeIndex];
        document.body.classList.add(newTheme);
    }

    function applyChatBackground(dataURL) {
        if (dataURL) {
            chatBox.style.backgroundImage = `url('${dataURL}')`;
            chatBox.classList.add('has-custom-bg');
            localStorage.setItem('chatBackground', dataURL);
        } else {
            clearChatBackground();
        }
    }

    function changeChatBackground(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            applyChatBackground(e.target.result);
        };
        reader.readAsDataURL(file);
    }

    function clearChatBackground() {
        chatBox.style.backgroundImage = '';
        chatBox.classList.remove('has-custom-bg');
        localStorage.removeItem('chatBackground');
    }

    async function startOrToggleCallUI() {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }

        if (videoCallContainer.classList.contains('hidden')) {
            videoCallContainer.classList.remove('hidden');
            if (!rtcPeerConnection) {
                try {
                    statusDiv.textContent = "Requesting camera access...";
                    await getLocalMediaStream(availableCameras[currentCameraIndex]?.deviceId);
                    localVideo.srcObject = localStream;
                    statusDiv.textContent = "Camera on. Initiating call...";
                    setupPeerConnection(true);
                } catch (error) {
                    console.error("Error accessing media devices.", error);
                    alert("Could not access your camera. Please grant permissions or ensure no other app is using it.");
                    statusDiv.textContent = "Error: Camera access denied.";
                    videoCallContainer.classList.add('hidden');
                    hangUp();
                }
            } else {
                statusDiv.textContent = "Call active.";
            }
        } else {
            if (rtcPeerConnection) {
                hangUp();
            }
            videoCallContainer.classList.add('hidden');
        }
        updateVideoCallButtonsState();
    }


    function logToSetup(msg) { document.getElementById('log').textContent = msg; }
    async function deriveKey(password) { const enc = new TextEncoder();const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);return crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode("p2p-chat-salt"), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]); }
    function checkStrength() { const val = document.getElementById('sharedKey').value;const meter = document.getElementById('strengthMeter');if (val.length > 15 && /[A-Z]/.test(val) && /[0-9]/.test(val) && /[^A-Za-z0-9]/.test(val)) {meter.textContent = 'üîí Strong Password'; meter.className = 'text-sm mt-1 text-green-500';} else if (val.length > 8) {meter.textContent = 'üü° Medium Strength'; meter.className = 'text-sm mt-1 text-yellow-500';} else {meter.textContent = 'üîì Weak Password'; meter.className = 'text-sm mt-1 text-red-500';}}
    function startChat() { 
        if (!document.getElementById('sharedKey').value) { logToSetup('Please enter a shared secret first.'); return; } 
        initPeer(true); 
        logToSetup('Signal generated. Copy and send it to your peer.'); 
    }
    async function connect() { 
        const sharedKeyInput = document.getElementById('sharedKey');
        const signalInInput = document.getElementById('signalIn');

        if (!sharedKeyInput.value) { logToSetup('Please enter a shared secret first.'); return; } 
        if (!signalInInput.value) { logToSetup('Please paste the peer\'s signal first.'); return; } 
        
        if (!peer) initPeer(false); 
        
        try { 
            const peerSignalData = JSON.parse(signalInInput.value);
            peer.signal(peerSignalData); 
            if (!aesKey) {
                aesKey = await deriveKey(sharedKeyInput.value);
            }
            logToSetup('Connecting to peer...');
            updatePeerStatus('Connecting...', false);
        } catch (e) { 
            logToSetup('‚ö†Ô∏è Invalid signal data or connection error. Please ensure the signal is correct.'); 
            console.error("Signal error during manual connect:", e);
            updatePeerStatus('Offline', false);
        } 
    }
    function copySignal() { 
        const out = document.getElementById('signalOut');
        if (!out.value) { logToSetup('Generate a signal first!'); return; }
        navigator.clipboard.writeText(out.value).then(() => logToSetup('Signal copied to clipboard.'), () => logToSetup('Failed to copy signal.')); 
    }

    function newConnection() {
        if (peer) {
            peer.destroy();
            peer = null;
        }
        if (rtcPeerConnection) {
            hangUp();
        }
        updatePeerStatus('Offline', false);
        window.location.reload(); 
    }
    
    // --- UI & LOGGING ---
    function log(content, type = 'system', msgId = '', replyTo = null) {
        const chatBox = document.getElementById('chatBox');
        const div = document.createElement('div');

        if ((type === 'sent' || type === 'received' || type === 'voice-message') && msgId) {
            chatMessages.push({ id: msgId, content: content, type: type });
            if (chatMessages.length > MAX_MESSAGES) {
                chatMessages.shift();
            }
        }
        
        if (type === 'system') {
            div.className = 'text-center my-2';
            div.innerHTML = `<span class="bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs font-semibold px-2 py-1 rounded-full">${content}</span>`;
        } else {
            const bubble = document.createElement('div');
            div.id = msgId;

            let messageContentHtml = '';
            if (replyTo && replyTo.contentSnippet) {
                const sanitizedSnippet = replyTo.contentSnippet.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 messageContentHtml += `
                    <div class="replied-message-content" onclick="scrollToMessage('${replyTo.id}')">
                        <p class="font-semibold text-sm">${sanitizedSnippet}</p>
                    </div>
                `;
            }
            messageContentHtml += content;


            bubble.className = 'message-bubble relative max-w-md md:max-lg px-3 py-2 rounded-lg shadow group';

            if (type === 'sent' || (type === 'voice-message' && content.includes('sent'))) {
                div.className = 'flex justify-end mb-2';
                bubble.classList.add('sent-bubble');
            } else {
                div.className = 'flex justify-start mb-2';
                bubble.classList.add('received-bubble');
            }
            bubble.innerHTML = messageContentHtml;
            div.appendChild(bubble);

            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'message-actions';
            let hasActions = false;

            if (type !== 'view-once-text' && !content.includes('View-Once Media')) {
                const replyButton = document.createElement('button');
                replyButton.className = 'action-button reply-btn';
                replyButton.innerHTML = '&#x21A9;'; // Reply arrow
                replyButton.title = 'Reply';
                replyButton.onclick = (e) => {
                    e.stopPropagation();
                    prepareReply(msgId);
                };
                actionsContainer.appendChild(replyButton);
                hasActions = true;
            }

            if (type === 'sent' || (type === 'voice-message' && content.includes('sent'))) {
                const deleteButton = document.createElement('button');
                deleteButton.className = 'action-button delete-btn';
                deleteButton.innerHTML = '&times;'; // 'X' symbol
                deleteButton.title = 'Delete';
                deleteButton.onclick = (e) => {
                    e.stopPropagation();
                    deleteMessage(msgId);
                };
                actionsContainer.appendChild(deleteButton);
                hasActions = true;
            }

            if (hasActions) {
                bubble.appendChild(actionsContainer);
            }
        }
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function scrollToMessage(messageId) {
        const messageElement = document.getElementById(messageId);
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            const originalBg = messageElement.querySelector('.message-bubble').style.backgroundColor;
            messageElement.querySelector('.message-bubble').style.backgroundColor = 'yellow';
            setTimeout(() => {
                messageElement.querySelector('.message-bubble').style.backgroundColor = originalBg;
            }, 1500);
        } else {
            log('Original message not found (may have been cleared).', 'system');
        }
    }


    // --- ENCRYPTION / DECRYPTION ---
    async function encrypt(data) { const enc = new TextEncoder();const iv = crypto.getRandomValues(new Uint8Array(12));const encryptedContent = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, enc.encode(data));const combined = new Uint8Array(iv.byteLength + encryptedContent.byteLength);combined.set(iv, 0);combined.set(new Uint8Array(encryptedContent), iv.byteLength);return combined; }
    async function decrypt(data) { const combined = new Uint8Array(data);const iv = combined.slice(0, 12);const ciphertext = combined.slice(12);const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, ciphertext);return new TextDecoder().decode(decrypted); }

    // --- P2P CORE LOGIC ---
    function initPeer(initiator) {
      peer = new SimplePeer({ initiator, trickle: false });
      updatePeerStatus('Connecting...', false);

      peer.on('signal', data => { 
          document.getElementById('signalOut').value = JSON.stringify(data); 
      });
      peer.on('connect', () => { 
          document.getElementById('setup').classList.add('hidden'); 
          document.getElementById('app').classList.remove('hidden'); 
          log('Connection established!'); 
          updatePeerStatus('Online', true);
          updateVideoCallButtonsState();
      });
      peer.on('error', err => { 
          console.error('Peer error:', err); 
          log('Connection error. Please try starting a new connection.', 'system'); 
          updatePeerStatus('Offline', false);
          hangUp(); 
          cancelFileTransfer(false);
          cancelImageStickerTransfer(false);
      }); 
      peer.on('close', () => { 
          log('Connection closed.', 'system'); 
          updatePeerStatus('Offline', false);
          hangUp();
          cancelFileTransfer(false);
          cancelImageStickerTransfer(false);
      });
      peer.on('data', async data => {
        try {
          if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); }
          const decrypted = await decrypt(data);
          const message = JSON.parse(decrypted);

          // --- MESSAGE HANDLER ---
          switch (message.type) {
              case 'text':
                  log(message.content, 'received', message.id, message.replyTo);
                  break;
              // VOICE MESSAGE FIX: Use mimeType from message for better compatibility
              case 'voice-message':
                  const blobType = message.mimeType || 'audio/webm'; // Fallback for old messages
                  const audioBlob = new Blob([Uint8Array.from(atob(message.chunk), c => c.charCodeAt(0))], { type: blobType });
                  const audioUrl = URL.createObjectURL(audioBlob);
                  const audioPlayer = `<div class="voice-message-player"><audio controls src="${audioUrl}"></audio></div>`;
                  log(audioPlayer, 'received', message.id, message.replyTo);
                  break;
              case 'typing':
                  if (peerStatusElement.textContent.includes('Online')) {
                      peerStatusElement.innerHTML = `<span class="h-2 w-2 bg-green-500 rounded-full mr-1 animate-pulse"></span><span class="italic">typing...</span>`;
                      clearTimeout(peerTypingTimer);
                      peerTypingTimer = setTimeout(() => {
                          updatePeerStatus('Online', true);
                      }, 2000);
                  }
                  break;
              case 'view-once-text':
                  const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceText(this, '${btoa(JSON.stringify(message.content))}')"><p class="font-bold">üëÅÔ∏è View-Once Message</p><p class="text-xs">Click to reveal</p></div>`;
                  log(placeholderHTML, 'received', message.id); 
                  break;
              case 'delete':
                  const msgEl = document.getElementById(message.id);
                  if (msgEl) {
                      msgEl.remove();
                      chatMessages = chatMessages.filter(msg => msg.id !== message.id);
                  }
                  break;
              case 'file-meta':
                  receivingFile = { ...message, chunks: [], receivedSize: 0 };
                  log(`Receiving file: <strong>${message.name}</strong> (${(message.size / 1024 / 1024).toFixed(2)} MB)`, 'system', message.id);
                  document.getElementById('progressContainer').style.display = 'flex';
                  document.getElementById('cancelFileBtn').classList.remove('hidden');
                  document.getElementById('progressLabel').textContent = `Receiving ${message.name}...`;
                  break;
              case 'file-chunk':
                  handleFileChunk(message);
                  break;
              case 'file-ack':
                  if (sendingFile.id === message.id) {
                      clearTimeout(sendingFile.ackTimeout);
                      sendingFile.lastAck = message.index;
                      sendChunk();
                  }
                  break;
              case 'file-cancel':
                  if (receivingFile.id === message.id) {
                      log(`File transfer for ${receivingFile.name} cancelled by peer.`, 'system');
                      receivingFile = {};
                      document.getElementById('progressContainer').style.display = 'none';
                      document.getElementById('cancelFileBtn').classList.add('hidden');
                  }
                  break;
              case 'webrtc-signal':
                  handleWebRTCSignal(message.signalData);
                  break;
              case 'call-rejected':
                  log('Your call was rejected by the peer.', 'system');
                  hangUp();
                  break;
              case 'call-ended':
                  log('The call was ended by the peer.', 'system');
                  hangUp();
                  break;
              case 'sticker':
                  let stickerHtmlContent;
                  const receivedSticker = message.content;
                  let saveButtonHtml = '';

                  if (receivedSticker.type === 'emoji') {
                      stickerHtmlContent = `<span class="sticker-message">${receivedSticker.content}</span>`;
                  } else if (receivedSticker.type === 'image') {
                      stickerHtmlContent = `<span class="sticker-message"><img src="${receivedSticker.content}" alt="Sticker"></span>`;
                      
                      const isAlreadySaved = userCustomStickers.some(s => areStickersEqual(s, receivedSticker));

                      if (!isAlreadySaved) {
                          const encodedSticker = btoa(JSON.stringify(receivedSticker));
                          saveButtonHtml = `<button class="save-sticker-btn text-xs px-2 py-1 bg-blue-500 text-white rounded-full mt-2 hover:bg-blue-600" onclick="saveReceivedSticker(this, '${encodedSticker}')">Save Sticker</button>`;
                      }
                  }
                  
                  const fullMessageContent = stickerHtmlContent + (saveButtonHtml ? `<div class="text-right">${saveButtonHtml}</div>` : '');
                  
                  log(fullMessageContent, 'received', message.id, message.replyTo);
                  addCustomSticker(receivedSticker);
                  break;
              case 'image-sticker-meta':
                  receivingImageSticker = { ...message, parts: [], receivedSize: 0 };
                  log(`Receiving image sticker.`, 'system');
                  document.getElementById('progressContainer').style.display = 'flex';
                  document.getElementById('cancelFileBtn').classList.remove('hidden');
                  document.getElementById('progressLabel').textContent = `Receiving sticker...`;
                  break;
              case 'image-sticker-chunk':
                  handleImageStickerChunk(message);
                  break;
              case 'image-sticker-ack':
                  if (sendingImageSticker.id === message.id) {
                      clearTimeout(sendingImageSticker.ackTimeout);
                      sendingImageSticker.lastAck = message.index;
                      sendImageStickerChunk();
                  }
                  break;
              case 'image-sticker-cancel':
                  if (receivingImageSticker.id === message.id) {
                      log(`Image sticker transfer cancelled by peer.`, 'system');
                      receivingImageSticker = {};
                      document.getElementById('progressContainer').style.display = 'none';
                      document.getElementById('cancelFileBtn').classList.add('hidden');
                  }
                  break;
          }
        } catch(e) { console.error(e); log('Failed to process message.', 'system'); }
      });
    }

    async function sendPacket(message) { 
        if (!peer || !peer.connected) { return false; } 
        if (!aesKey) { aesKey = await deriveKey(document.getElementById('sharedKey').value); } 
        try { 
            peer.send(await encrypt(JSON.stringify(message))); 
            return true; 
        } catch (err) { 
            console.error("Send failed:", err); 
            log(`Failed to send packet.`, 'system'); 
            return false; 
        } 
    }
    async function sendMessage() { 
        const msgInput = document.getElementById('message');
        if (!msgInput.value.trim()) return;

        const messageContent = msgInput.value.replace(/\n/g, '<br>');
        const isViewOnce = document.getElementById('viewOnce').checked;
        const messageId = `msg-${Date.now()}`;
        const messageType = isViewOnce ? 'view-once-text' : 'text';

        const messageToSend = {
            type: messageType,
            content: messageContent,
            id: messageId
        };

        if (currentReplyTo) {
            messageToSend.replyTo = { ...currentReplyTo };
        }

        if (await sendPacket(messageToSend)) {
            if (!isViewOnce) {
                const sentHTML = messageContent;
                log(sentHTML, 'sent', messageId, currentReplyTo);
            } else {
                log(`<i>Sent a 'view-once' message.</i>`, 'sent', messageId); 
            }
            msgInput.value = ''; 
            msgInput.style.height = 'auto';
            document.getElementById('viewOnce').checked = false;
            cancelReply();
        } 
    }

    // --- VIEW-ONCE, DELETE & FULLSCREEN ---
    function revealOnceText(element, encodedContent) { 
        element.innerHTML = JSON.parse(atob(encodedContent));
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
        setTimeout(() => element.parentElement.remove(), 8000); 
    }
    
    function revealOnceMedia(element, blobId) {
        const blobInfo = viewOnceBlobs[blobId];
        if (!blobInfo) return;
        if (blobInfo.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = blobInfo.url;
            img.className = "max-w-xs rounded-lg";
            img.alt = "View-once Image";
            img.oncontextmenu = () => false;
            element.innerHTML = '';
            element.appendChild(img);
            setTimeout(() => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            }, 5000);
        } else if (blobInfo.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = blobInfo.url;
            video.autoplay = true;
            video.className = "max-w-xs rounded-lg";
            video.oncontextmenu = () => false;
            video.onended = () => {
                element.parentElement.remove(); 
                URL.revokeObjectURL(blobInfo.url);
                delete viewOnceBlobs[blobId];
            };
            element.innerHTML = '';
            element.appendChild(video);
        }
        element.classList.remove('cursor-pointer', 'p-2', 'bg-gray-300', 'dark:bg-gray-600');
        element.onclick = null;
    }
    function showFullscreenImage(src) { document.getElementById('fullscreen-image').src = src; document.getElementById('fullscreen-viewer').classList.remove('hidden'); }
    function hideFullscreenImage() { document.getElementById('fullscreen-viewer').classList.add('hidden'); }

    async function deleteMessage(messageId) {
        chatMessages = chatMessages.filter(msg => msg.id !== messageId);
        if (await sendPacket({ type: 'delete', id: messageId })) {
            const msgElementToRemove = document.getElementById(messageId);
            if (msgElementToRemove) {
                msgElementToRemove.remove(); 
            }
        }
    }

    // --- FILE TRANSFER ---
    async function handleFileChunk(message) {
      if (receivingFile.id !== message.id) return;
      const chunk = Uint8Array.from(atob(message.chunk), c => c.charCodeAt(0));
      receivingFile.chunks[message.index] = chunk; receivingFile.receivedSize += chunk.byteLength;
      document.getElementById('progressBar').style.width = `${(receivingFile.receivedSize / receivingFile.size) * 100}%`;
      await sendPacket({ type: 'file-ack', id: message.id, index: message.index });
      if (receivingFile.receivedSize === receivingFile.size) {
          const fileBlob = new Blob(receivingFile.chunks, {type: receivingFile.fileType});
          if (receivingFile.isViewOnce) {
              const blobId = `blob-${Date.now()}`;
              viewOnceBlobs[blobId] = { url: URL.createObjectURL(fileBlob), type: receivingFile.fileType, name: receivingFile.name };
              const mediaIcon = receivingFile.fileType.startsWith('image/') ? 'üñºÔ∏è' : 'üéûÔ∏è';
              const placeholderHTML = `<div class="cursor-pointer p-2 bg-gray-300 dark:bg-gray-600 rounded-lg" onclick="revealOnceMedia(this, '${blobId}')"><p class="font-bold">${mediaIcon} View-Once Media</p><p class="text-xs>${receivingFile.name} - Click to reveal</p></div>`;
              log(placeholderHTML, 'received', receivingFile.id); 
          } else {
              const url = URL.createObjectURL(fileBlob);
              let mediaHTML = '';
              if (receivingFile.fileType.startsWith('image/')) {
                  mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Received Image" onclick="showFullscreenImage(this.src)">`;
              } else if (receivingFile.fileType.startsWith('video/')) {
                  mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
              }
              const downloadUI = `<div class="mt-2 p-2 bg-gray-100 dark:bg-gray-600 rounded-lg flex items-center justify-between"><div class="text-sm"><strong>${receivingFile.name}</strong></div><a href="${url}" download="${receivingFile.name}" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-500"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg></a></div>`;
              log(mediaHTML + downloadUI, 'received', receivingFile.id); 
          }
          receivingFile = {};
          setTimeout(() => { 
            document.getElementById('progressContainer').style.display = 'none'; 
            document.getElementById('cancelFileBtn').classList.add('hidden'); 
          }, 2000);
      }
    }

    function queueFilesForSending(event) {
        const files = event.target.files;
        if (!files.length) return;

        for (const file of files) {
            fileSendQueue.push(file);
        }

        if (!sendingFile.id && !sendingImageSticker.id) {
            startNextFileTransfer();
        }
        event.target.value = null; 
    }
    
    function startNextFileTransfer() {
        if (fileSendQueue.length === 0) {
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('cancelFileBtn').classList.add('hidden');
            }, 2000);
            return;
        }

        const file = fileSendQueue[0];

        if (sendingFile.id || sendingImageSticker.id) {
            log('A transfer is already in progress.', 'system');
            return;
        }
        
        const isViewOnce = document.getElementById('viewOnce').checked;
        const fileId = `file-${Date.now()}`;
        
        log(`Preparing to send: <strong>${file.name}</strong> (${fileSendQueue.length} file(s) in queue)...`, 'system', fileId);
        document.getElementById('progressContainer').style.display = 'flex'; 
        document.getElementById('cancelFileBtn').classList.remove('hidden'); 
        document.getElementById('progressLabel').textContent = `Sending ${file.name}...`;
        document.getElementById('progressBar').style.width = '0%';

        fileReader = new FileReader(); 
        fileReader.onload = async (e) => {
            sendingFile = { 
                id: fileId, name: file.name, type: file.type, size: file.size, isViewOnce, 
                chunks: [], buffer: e.target.result, currentIndex: 0, lastAck: -1 
            };
            for (let i = 0; i < e.target.result.byteLength; i += CHUNK_SIZE) {
                sendingFile.chunks.push(e.target.result.slice(i, i + CHUNK_SIZE));
            }
            if(await sendPacket({ type: 'file-meta', id: fileId, name: file.name, size: file.size, fileType: file.type, isViewOnce })) {
                sendChunk();
            } else { 
                log(`Could not initiate file transfer for ${file.name}.`, 'system'); 
                cancelFileTransfer(false); 
            }
        };
        fileReader.onerror = (e) => {
            console.error("FileReader error:", e);
            log(`Error reading file ${file.name}.`, "system");
            cancelFileTransfer(false);
        };
        fileReader.readAsArrayBuffer(file); 
    }

    function sendChunk() {
        if (!sendingFile.id) return;
        
        if (sendingFile.currentIndex >= sendingFile.chunks.length) {
            if (!sendingFile.isViewOnce) {
                const fileBlob = new Blob([sendingFile.buffer], {type: sendingFile.type});
                const url = URL.createObjectURL(fileBlob);
                let mediaHTML = '';
                if (sendingFile.type.startsWith('image/')) {
                    mediaHTML = `<img src="${url}" class="max-w-xs rounded-lg mt-2 cursor-pointer" alt="Sent Image" onclick="showFullscreenImage(this.src)">`;
                } else if (sendingFile.type.startsWith('video/')) {
                    mediaHTML = `<video src="${url}" controls class="max-w-xs rounded-lg mt-2"></video>`;
                }
                log(mediaHTML, 'sent', sendingFile.id); 
            } else {
                log(`<i>Sent a 'view-once' file: ${sendingFile.name}</i>`, 'sent', sendingFile.id); 
            }

            sendingFile = {};
            fileSendQueue.shift();
            
            if (fileSendQueue.length === 0) {
                 document.getElementById('viewOnce').checked = false; 
            }
            
            startNextFileTransfer(); 
            return;
        }

        if (sendingFile.currentIndex > sendingFile.lastAck + 1) return;

        const chunk = sendingFile.chunks[sendingFile.currentIndex];
        const base64Chunk = btoa(new Uint8Array(chunk).reduce((data, byte) => data + String.fromCharCode(byte), ''));
        sendPacket({ type: 'file-chunk', id: sendingFile.id, index: sendingFile.currentIndex, chunk: base64Chunk }).then(sent => {
            if (sent) {
                sendingFile.ackTimeout = setTimeout(() => { log(`No ACK for file chunk ${sendingFile.currentIndex}, retrying...`, 'system'); sendChunk(); }, 10000);
                document.getElementById('progressBar').style.width = `${((sendingFile.currentIndex + 1) / sendingFile.chunks.length) * 100}%`;
                if (sendingFile.currentIndex === sendingFile.lastAck + 1) sendingFile.currentIndex++;
            } else { 
                log(`Critical send failure for file chunk ${sendingFile.currentIndex}. Aborting transfer.`, 'system'); 
                clearTimeout(sendingFile.ackTimeout); 
                cancelFileTransfer(false); 
            }
        });
    }

    function cancelFileTransfer(shouldNotifyPeer) {
        if (fileReader) {
            fileReader.abort(); 
            fileReader = null;
        }
        
        if (sendingFile.id && shouldNotifyPeer) {
            sendPacket({ type: 'file-cancel', id: sendingFile.id });
            log(`File transfer for ${sendingFile.name} cancelled.`, 'system');
        } else if (receivingFile.id && shouldNotifyPeer) {
            sendPacket({ type: 'file-cancel', id: receivingFile.id });
            log(`Receiving file transfer for ${receivingFile.name} cancelled.`, 'system');
        }
        
        if (fileSendQueue.length > 0) {
            log(`Cleared ${fileSendQueue.length} pending file(s) from the queue.`, 'system');
            fileSendQueue = [];
        }
        
        clearTimeout(sendingFile.ackTimeout); 
        sendingFile = {}; 
        receivingFile = {}; 

        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('cancelFileBtn').classList.add('hidden'); 
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressLabel').textContent = '';
    }

    // --- WebRTC CALLING LOGIC (merged with data channel) ---
    async function getLocalMediaStream(deviceId = null) {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        const constraints = {
            video: deviceId ? { deviceId: { exact: deviceId } } : true,
            audio: true
        };
        try {
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            localVideo.srcObject = localStream;
            if (rtcPeerConnection) {
                const videoSender = rtcPeerConnection.getSenders().find(sender => sender.track.kind === 'video');
                const audioSender = rtcPeerConnection.getSenders().find(sender => sender.track.kind === 'audio');
                if (videoSender && localStream.getVideoTracks().length > 0) {
                    await videoSender.replaceTrack(localStream.getVideoTracks()[0]);
                } else if (localStream.getVideoTracks().length > 0) {
                    rtcPeerConnection.addTrack(localStream.getVideoTracks()[0], localStream);
                }
                if (audioSender && localStream.getAudioTracks().length > 0) {
                    await audioSender.replaceTrack(localStream.getAudioTracks()[0]);
                } else if (localStream.getAudioTracks().length > 0) {
                    rtcPeerConnection.addTrack(localStream.getAudioTracks()[0], localStream);
                }
            }
            return true;
        } catch (error) {
            console.error("Error accessing media devices:", error);
            alert("Could not access your camera. Please grant permissions or ensure no other app is using it.");
            statusDiv.textContent = "Error: Camera access denied.";
            localStream = null;
            if (rtcPeerConnection) {
                hangUp();
            }
            return false;
        } finally {
             updateVideoCallButtonsState();
        }
    }


    function updateVideoCallButtonsState() {
        const isPeerConnected = peer && peer.connected;
        const inCall = !!rtcPeerConnection;
        const isIncomingCall = !incomingCallNotification.classList.contains('hidden');
        const hasMultipleCameras = availableCameras.length > 1;

        if (!isIncomingCall && incomingCallNotification.style.display !== 'none') {
            incomingCallNotification.classList.add('hidden');
        }

        callButton.disabled = !isPeerConnected || inCall || isIncomingCall;
        callButton.style.display = (inCall || isIncomingCall) ? 'none' : '';

        hangupButton.disabled = !isPeerConnected || (!inCall && !isIncomingCall);
        hangupButton.style.display = (inCall || isIncomingCall) ? '' : 'none';

        switchCameraButton.disabled = !localStream || !hasMultipleCameras;
        switchCameraButton.style.display = (localStream && hasMultipleCameras) ? '' : 'none';

        if (isIncomingCall) {
            acceptCallButton.style.display = '';
            rejectCallButton.style.display = '';
            acceptCallButton.disabled = !isPeerConnected;
            rejectCallButton.disabled = !isPeerConnected;
        } else {
            acceptCallButton.style.display = 'none';
            rejectCallButton.style.display = 'none';
        }

        if (!isPeerConnected) {
            statusDiv.textContent = 'Not connected to peer chat.';
        } else if (!localStream && !inCall && !isIncomingCall) {
            statusDiv.textContent = 'Camera Off. Ready to start call.';
        } else if (isIncomingCall) {
            statusDiv.textContent = 'Incoming Call...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'new') {
            statusDiv.textContent = 'Initiating call...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'connecting') {
            statusDiv.textContent = 'Connecting...';
        } else if (rtcPeerConnection && rtcPeerConnection.connectionState === 'connected') {
                statusDiv.textContent = 'Call Connected!';
                statusDiv.style.display = 'block';
                setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
                updateVideoCallButtonsState();
            } else if (rtcPeerConnection && ['disconnected', 'closed', 'failed'].includes(rtcPeerConnection.connectionState)) {
                 statusDiv.textContent = 'Call ended.';
                 statusDiv.style.display = 'block';
            } else {
                statusDiv.textContent = 'Ready to start call.';
            }
        }


    const setupPeerConnection = (isInitiator) => {
        rtcPeerConnection = new RTCPeerConnection(servers);
        
        if (localStream) {
            localStream.getTracks().forEach(track => rtcPeerConnection.addTrack(track, localStream));
        }

        rtcPeerConnection.ontrack = event => {
            const [remoteStream] = event.streams;
            remoteVideo.srcObject = remoteStream;
            statusDiv.style.display = 'none';
        };

        rtcPeerConnection.onicecandidate = event => {
            if (event.candidate) {
                sendPacket({ type: 'webrtc-signal', signalData: { type: 'candidate', candidate: event.candidate } });
            }
        };

        rtcPeerConnection.onnegotiationneeded = async () => {
            if (isInitiator) {
                try {
                    const offer = await rtcPeerConnection.createOffer();
                    await rtcPeerConnection.setLocalDescription(offer);
                    sendPacket({ type: 'webrtc-signal', signalData: { type: 'offer', sdp: rtcPeerConnection.localDescription } });
                    statusDiv.textContent = "Sending call offer. Waiting for peer to accept...";
                } catch (e) {
                    console.error("Error creating offer:", e);
                    statusDiv.textContent = "Error creating call offer.";
                    hangUp();
                }
            }
        };

        rtcPeerConnection.onconnectionstatechange = () => {
            console.log("RTC connection state:", rtcPeerConnection.connectionState);
            if (rtcPeerConnection.connectionState === 'connected') {
                statusDiv.textContent = 'Call Connected!';
                statusDiv.style.display = 'block';
                setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
                updateVideoCallButtonsState();
            } else if (['disconnected', 'closed', 'failed'].includes(rtcPeerConnection.connectionState)) {
                hangUp();
            }
        };
        updateVideoCallButtonsState();
    };

    callButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }
        if (rtcPeerConnection) {
            log('A call is already active or being attempted.', 'system');
            return;
        }
        try {
            statusDiv.textContent = "Requesting camera access...";
            await getLocalMediaStream(availableCameras[currentCameraIndex]?.deviceId);
            statusDiv.textContent = "Camera on. Initiating call...";
            setupPeerConnection(true);
        } catch (error) {
            console.error("Error accessing media devices.", error);
            alert("Could not access your camera. Please grant permissions or ensure no other app is using it.");
            statusDiv.textContent = "Error: Camera access denied.";
            hangUp();
        } finally {
            updateVideoCallButtonsState();
        }
    };


    acceptCallButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Please establish the main chat connection first.");
            return;
        }
        if (!incomingCallOffer) {
            console.error("No incoming offer to accept.");
            return;
        }

        incomingCallNotification.classList.add('hidden');
        statusDiv.textContent = "Accepting call...";
        videoCallContainer.classList.remove('hidden');

        try {
            if (!localStream) {
                await getLocalMediaStream(availableCameras[currentCameraIndex]?.deviceId);
                statusDiv.textContent = "Camera on. Connecting...";
            }
            
            if (!rtcPeerConnection) {
                setupPeerConnection(false);
            } 
            
            await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(incomingCallOffer));
            const answer = await rtcPeerConnection.createAnswer();
            await rtcPeerConnection.setLocalDescription(answer);
            sendPacket({ type: 'webrtc-signal', signalData: { type: 'answer', sdp: rtcPeerConnection.localDescription } });
            statusDiv.textContent = "Sending call answer...";
        } catch (e) {
            console.error("Error accepting call:", e);
            alert("Failed to accept call. Check camera permissions.");
            statusDiv.textContent = "Error accepting call.";
            hangUp();
        } finally {
            incomingCallOffer = null;
            updateVideoCallButtonsState();
        }
    };

    rejectCallButton.onclick = async () => {
        if (!peer || !peer.connected) {
            alert("Main chat connection not established.");
            return;
        }
        incomingCallNotification.classList.add('hidden');
        statusDiv.textContent = "Call Rejected.";
        sendPacket({ type: 'call-rejected' });
        incomingCallOffer = null;
        hangUp();
    };

    switchCameraButton.onclick = async () => {
        if (!localStream) {
            log('No active camera to switch.', 'system');
            return;
        }
        if (availableCameras.length <= 1) {
            log('Only one camera detected.', 'system');
            return;
        }
        currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;
        const nextCameraId = availableCameras[currentCameraIndex].deviceId;
        log(`Switching to camera: ${availableCameras[currentCameraIndex].label || 'Unnamed Camera'}`, 'system');
        statusDiv.textContent = "Switching camera...";
        await getLocalMediaStream(nextCameraId);
    };


    async function handleWebRTCSignal(signalData) {
        if (signalData.type === 'offer') {
            if (rtcPeerConnection && rtcPeerConnection.connectionState !== 'closed' && rtcPeerConnection.connectionState !== 'new') {
                console.warn("Already in a call or call setup. Ignoring new offer.");
                return;
            }
            incomingCallOffer = signalData.sdp;
            incomingCallNotification.classList.remove('hidden');
            statusDiv.textContent = "Incoming Call...";
            log('Incoming video call. Click Accept or Reject.', 'system');
            updateVideoCallButtonsState();
        } else if (signalData.type === 'answer') {
            if (rtcPeerConnection && rtcPeerConnection.localDescription.type === 'offer') {
                try {
                    await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(signalData.sdp));
                    statusDiv.textContent = "Call established!";
                } catch (e) {
                    console.error("Error setting remote answer:", e);
                    statusDiv.textContent = "Error during call setup.";
                    hangUp();
                }
            } else {
                console.warn("Received answer but not expecting one.", signalData);
            }
        } else if (signalData.type === 'candidate') {
            if (rtcPeerConnection) {
                try {
                    await rtcPeerConnection.addIceCandidate(new RTCIceCandidate(signalData.candidate));
                } catch (e) {
                    console.error("Error adding ICE candidate:", e);
                }
            } else {
                console.warn("Received ICE candidate but RTCPeerConnection is not initialized.", signalData);
            }
        }
    }

    function hangUp() {
        if (rtcPeerConnection) {
            if (peer && peer.connected) {
                sendPacket({ type: 'call-ended' });
            }
            rtcPeerConnection.close();
            rtcPeerConnection = null;
        }
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        incomingCallNotification.classList.add('hidden');
        incomingCallOffer = null;
        videoCallContainer.classList.add('hidden'); 
        updateVideoCallButtonsState();
    }

    hangupButton.onclick = hangUp;

    document.getElementById('message').addEventListener('input', () => {
        if (typingTimer) return;
        sendPacket({ type: 'typing' });
        typingTimer = setTimeout(() => {
            typingTimer = null;
        }, 1200);
    });

    function updatePeerStatus(statusText, isOnline) {
        clearTimeout(peerTypingTimer);
        if (!peerStatusElement) return;
        
        peerStatusElement.textContent = statusText;
        if (isOnline) {
            peerStatusElement.className = 'text-sm font-semibold text-green-500 flex items-center';
            peerStatusElement.innerHTML = `<span class="h-2 w-2 bg-green-500 rounded-full mr-1"></span>${statusText}`;
        } else {
            peerStatusElement.className = 'text-sm font-semibold text-gray-500 flex items-center';
            peerStatusElement.innerHTML = `<span class="h-2 w-2 bg-gray-500 rounded-full mr-1"></span>${statusText}`;
        }
    }

    // --- Reply Functions ---
    /**
     * Creates a thumbnail from a video source URL.
     * @param {string} videoSrc - The source URL of the video.
     * @returns {Promise<string>} A promise that resolves with the data URL of the thumbnail.
     */
    function createVideoThumbnail(videoSrc) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.crossOrigin = "anonymous";
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            video.onloadeddata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                resolve(canvas.toDataURL('image/jpeg'));
                video.remove();
                canvas.remove();
            };

            video.onerror = (e) => {
                reject(new Error("Failed to load video for thumbnail generation."));
                video.remove();
                canvas.remove();
            };

            video.src = videoSrc;
        });
    }

    async function prepareReply(messageId) {
        const originalMessage = chatMessages.find(msg => msg.id === messageId);
        if (!originalMessage) {
            log('Cannot reply to a message that is no longer in chat history.', 'system');
            return;
        }
        const replyPreviewContent = document.querySelector('#replyPreview .content');
        if (!replyPreviewContent) return;

        let snippetHTML;
        let snippetForPacket;

        if (originalMessage.content.includes('<video')) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalMessage.content;
            const videoSrc = tempDiv.querySelector('video')?.src;
            if (videoSrc) {
                try {
                    const videoThumbnailUrl = await createVideoThumbnail(videoSrc);
                    snippetHTML = `<img src="${videoThumbnailUrl}" style="width: 32px; height: 32px; object-fit: cover; border-radius: 4px; margin-right: 8px;"> <span>Video</span>`;
                    snippetForPacket = 'üìπ Video';
                } catch (error) {
                    console.error("Failed to create video thumbnail for reply:", error);
                    snippetHTML = 'üé¨ Video';
                    snippetForPacket = 'üé¨ Video';
                }
            } else {
                snippetHTML = 'Media File';
                snippetForPacket = 'üìé Media';
            }
        } else if (originalMessage.content.includes('<img')) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalMessage.content;
            const imgSrc = tempDiv.querySelector('img')?.src;
            if (imgSrc) {
                snippetHTML = `<img src="${imgSrc}" style="width: 32px; height: 32px; object-fit: cover; border-radius: 4px; margin-right: 8px;"> <span>Image / Sticker</span>`;
                snippetForPacket = 'üì∑ Image';
            } else {
                snippetHTML = 'Media File';
                snippetForPacket = 'üìé Media';
            }
        } else if (originalMessage.type === 'voice-message') {
             snippetHTML = `üé§ Voice Message`;
             snippetForPacket = `üé§ Voice Message`;
        } else {
            const textContent = originalMessage.content.replace(/<br>/g, ' ').replace(/<button.*?<\/button>/g, '').trim();
            snippetForPacket = textContent.substring(0, 50) + (textContent.length > 50 ? '...' : '');
            snippetHTML = snippetForPacket;
        }

        currentReplyTo = { id: messageId, contentSnippet: snippetForPacket };
        replyPreviewContent.innerHTML = `Replying to: ${snippetHTML}`;
        replyPreview.classList.remove('hidden');
        document.getElementById('message').focus();
    }


    function cancelReply() {
        currentReplyTo = null;
        const replyPreviewContent = document.querySelector('#replyPreview .content');
        if(replyPreviewContent) {
            replyPreviewContent.innerHTML = `Replying to: <span id="replyContentSnippet" class="font-semibold text-gray-800 dark:text-gray-200"></span>`;
        }
        replyPreview.classList.add('hidden');
    }


    // --- Sticker Functions ---
    function areStickersEqual(s1, s2) {
        return s1.type === s2.type && s1.content === s2.content;
    }

    function loadCustomStickers() {
        const storedStickers = localStorage.getItem(CUSTOM_STICKERS_STORAGE_KEY);
        if (storedStickers) {
            try {
                userCustomStickers = JSON.parse(storedStickers);
                userCustomStickers = userCustomStickers.filter(s => s.type && s.content && s.type === 'image');
            } catch (e) {
                console.error("Error parsing custom stickers from localStorage:", e);
                userCustomStickers = [];
            }
        }
    }

    function saveCustomStickers() {
        localStorage.setItem(CUSTOM_STICKERS_STORAGE_KEY, JSON.stringify(userCustomStickers));
    }

    function addCustomSticker(stickerObject) {
        if (stickerObject.type === 'image') {
            userCustomStickers = userCustomStickers.filter(s => !areStickersEqual(s, stickerObject));
            userCustomStickers.unshift(stickerObject);
            if (userCustomStickers.length > MAX_RECENT_STICKERS) {
                userCustomStickers = userCustomStickers.slice(0, MAX_RECENT_STICKERS);
            }
            saveCustomStickers();
            renderStickerPickerContent();
        } else if (stickerObject.type === 'emoji') {
            renderStickerPickerContent();
        }
    }

    function clearCustomStickers() {
        userCustomStickers = [];
        saveCustomStickers();
        renderStickerPickerContent();
        log('Your custom sticker collection has been cleared.', 'system');
    }

    function renderStickerPickerContent() {
        allStickersGrid.innerHTML = '';
        let allStickersToDisplay = [];
        userCustomStickers.forEach(sticker => {
            allStickersToDisplay.push(sticker);
        });
        predefinedStickers.forEach(predefined => {
            const isDuplicate = allStickersToDisplay.some(existing => areStickersEqual(existing, predefined));
            if (!isDuplicate) {
                allStickersToDisplay.push(predefined);
            }
        });
        
        if (allStickersToDisplay.length > 0) {
            allStickersToDisplay.forEach(sticker => {
                const stickerItem = document.createElement('div');
                stickerItem.className = 'sticker-item group';
                stickerItem.onclick = () => sendSticker(sticker); 

                if (sticker.type === 'emoji') {
                    stickerItem.textContent = sticker.content;
                } else if (sticker.type === 'image') {
                    const img = document.createElement('img');
                    img.src = sticker.content;
                    img.alt = 'Sticker';
                    img.style.width = '40px';
                    img.style.height = '40px';
                    img.style.objectFit = 'contain';
                    img.onerror = function() {
                        this.onerror = null;
                        this.src = 'https://placehold.co/40x40/cccccc/000000?text=ERR';
                        this.alt = 'Broken Sticker Image';
                        console.warn(`Could not load sticker image: ${sticker.content}`);
                    };
                    stickerItem.appendChild(img);
                }
                
                const isUserCustomSticker = userCustomStickers.some(s => areStickersEqual(s, sticker));
                if (isUserCustomSticker) {
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn hidden group-hover:block';
                    removeBtn.textContent = '√ó';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeCustomSticker(sticker);
                    };
                    stickerItem.appendChild(removeBtn);
                }
                allStickersGrid.appendChild(stickerItem);
            });
        } else {
            allStickersGrid.innerHTML = '<div class="text-center text-sm text-gray-500 col-span-full">No stickers available.</div>';
        }
    }

    function removeCustomSticker(stickerObjectToRemove) {
        userCustomStickers = userCustomStickers.filter(s => !areStickersEqual(s, stickerObjectToRemove));
        saveCustomStickers();
        renderStickerPickerContent();
        log('Custom sticker removed.', 'system');
    }


    function toggleStickerPicker() {
        if (stickerPicker.classList.contains('hidden')) {
            stickerPicker.classList.remove('hidden');
            stickerPicker.style.display = 'flex';
            renderStickerPickerContent();
        } else {
            stickerPicker.classList.add('hidden');
            stickerPicker.style.display = 'none';
        }
    }

    async function sendSticker(stickerObject) {
        if (!peer || !peer.connected) {
            log('Not connected. Cannot send sticker.', 'system');
            return;
        }
        if (sendingFile.id || sendingImageSticker.id) {
            log('A file or sticker transfer is already in progress. Please wait.', 'system');
            return;
        }
        if (!stickerObject || !stickerObject.type || !stickerObject.content) {
            console.error("Invalid sticker object to send:", stickerObject);
            log('Error sending sticker: Invalid format.', 'system');
            return;
        }

        if (stickerObject.type === 'image') {
            addCustomSticker(stickerObject); 
        }

        const messageId = `sticker-${stickerObject.type}-${Date.now()}`;
        const messageToSend = {
            type: 'sticker',
            content: stickerObject,
            id: messageId
        };

        if (currentReplyTo) {
            messageToSend.replyTo = { ...currentReplyTo };
        }

        if (await sendPacket(messageToSend)) {
            let sentHtml;
            if (stickerObject.type === 'emoji') {
                sentHtml = `<span class="sticker-message">${stickerObject.content}</span>`;
            } else if (stickerObject.type === 'image') {
                sentHtml = `<span class="sticker-message"><img src="${stickerObject.content}" alt="Sticker"></span>`;
            }
            log(sentHtml, 'sent', messageId, currentReplyTo);
            toggleStickerPicker();
            cancelReply();
        } else {
            log(`Could not send sticker.`, 'system');
        }
    }

    function addCustomStickerUrl() {
        const url = customStickerUrlInput.value.trim();
        customStickerUrlError.classList.add('hidden');

        if (!url) {
            customStickerUrlError.textContent = 'Please enter a URL.';
            customStickerUrlError.classList.remove('hidden');
            return;
        }

        try {
            new URL(url);
        } catch (e) {
            customStickerUrlError.textContent = 'Invalid URL format.';
            customStickerUrlError.classList.remove('hidden');
            return;
        }

        const lowerCaseUrl = url.toLowerCase();
        if (!lowerCaseUrl.endsWith('.gif') && !lowerCaseUrl.endsWith('.webp') &&
            !lowerCaseUrl.endsWith('.png') && !lowerCaseUrl.endsWith('.jpg') &&
            !lowerCaseUrl.endsWith('.jpeg')) {
            customStickerUrlError.textContent = 'Only image URLs (gif, webp, png, jpg) are recommended.';
            customStickerUrlError.classList.remove('hidden');
        }

        const newSticker = { type: 'image', content: url };
        addCustomSticker(newSticker);
        customStickerUrlInput.value = '';
        log(`Custom sticker URL added: ${url}`, 'system');
    }

    function saveReceivedSticker(buttonElement, encodedSticker) {
        try {
            const stickerToSave = JSON.parse(atob(encodedSticker));
            addCustomSticker(stickerToSave);
            buttonElement.remove();
            log(`Sticker saved to your collection!`, 'system');
        } catch (e) {
            console.error("Error saving received sticker:", e);
            log("Failed to save sticker.", "system");
        }
    }


    async function sendImageStickerChunk() {
        if (!sendingImageSticker.id || sendingImageSticker.currentIndex > sendingImageSticker.lastAck + 1) return;

        if (sendingImageSticker.currentIndex >= sendingImageSticker.chunks.length) {
            const sentHtml = `<span class="sticker-message"><img src="${sendingImageSticker.dataUrl}" alt="Sticker"></span>`;
            log(sentHtml, 'sent', sendingImageSticker.id);
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('cancelFileBtn').classList.add('hidden');
            }, 2000);
            sendingImageSticker = {};
            return;
        }

        const chunk = sendingImageSticker.chunks[sendingImageSticker.currentIndex];
        
        sendPacket({
            type: 'image-sticker-chunk',
            id: sendingImageSticker.id,
            index: sendingImageSticker.currentIndex,
            chunk: chunk
        }).then(sent => {
            if (sent) {
                sendingImageSticker.ackTimeout = setTimeout(() => {
                    log(`No ACK for image sticker chunk ${sendingImageSticker.currentIndex}, retrying...`, 'system');
                    sendImageStickerChunk();
                }, 10000);
                document.getElementById('progressBar').style.width =
                    `${((sendingImageSticker.currentIndex + 1) / sendingImageSticker.chunks.length) * 100}%`;
                
                if (sendingImageSticker.currentIndex === sendingImageSticker.lastAck + 1) {
                    sendingImageSticker.currentIndex++;
                }
            } else {
                log(`Critical send failure for image sticker chunk ${sendingImageSticker.currentIndex}. Aborting transfer.`, 'system');
                clearTimeout(sendingImageSticker.ackTimeout);
                cancelImageStickerTransfer(false);
            }
        });
    }

    async function handleImageStickerChunk(message) {
        if (receivingImageSticker.id !== message.id) return;

        receivingImageSticker.parts[message.index] = message.chunk;
        receivingImageSticker.receivedSize += atob(message.chunk).length;

        document.getElementById('progressBar').style.width =
            `${(receivingImageSticker.receivedSize / receivingImageSticker.size) * 100}%`;
        
        await sendPacket({ type: 'image-sticker-ack', id: message.id, index: message.index });

        if (receivingImageSticker.receivedSize >= receivingImageSticker.size) {
            const fullDataUrl = `data:${receivingImageSticker.fileType};base64,${receivingImageSticker.parts.join('')}`;
            
            const receivedHtml = `<span class="sticker-message"><img src="${fullDataUrl}" alt="Sticker"></span>`;
            log(receivedHtml, 'received', receivingImageSticker.id);
            addCustomSticker({ type: 'image', content: fullDataUrl });
            
            receivingImageSticker = {};
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('cancelFileBtn').classList.add('hidden');
            }, 2000);
        }
    }

    function cancelImageStickerTransfer(shouldNotifyPeer) {
        if (sendingImageSticker.id && shouldNotifyPeer) {
            sendPacket({ type: 'image-sticker-cancel', id: sendingImageSticker.id });
            log(`Image sticker transfer cancelled.`, 'system');
        } else if (receivingImageSticker.id && shouldNotifyPeer) {
            sendPacket({ type: 'image-sticker-cancel', id: receivingImageSticker.id });
            log(`Receiving image sticker transfer cancelled.`, 'system');
        }

        clearTimeout(sendingImageSticker.ackTimeout);
        sendingImageSticker = {};
        receivingImageSticker = {};

        document.getElementById('progressContainer').style.display = 'none';
        document.getElementById('cancelFileBtn').classList.add('hidden');
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressLabel').textContent = '';
    }

    // --- Voice Message Functions ---
    const recordButton = document.getElementById('recordButton');
    const recordingIndicator = document.getElementById('recordingIndicator');
    const recordingTimer = document.getElementById('recordingTimer');

    // MODIFICATION: Re-architected voice recording to fix stream closing issue.
    async function startRecording() {
        if (!peer || !peer.connected) {
            log('Please connect to a peer first.', 'system');
            return;
        }

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            const mimeTypes = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
                'audio/mp4' // For Safari compatibility
            ];
            const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';
            console.log("Using MIME type for recording:", supportedMimeType || "browser default");
            
            mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });
            audioChunks = [];

            mediaRecorder.addEventListener("dataavailable", event => {
                audioChunks.push(event.data);
            });

            mediaRecorder.addEventListener("stop", async () => {
                // Stop the stream tracks here to release the microphone. This is the fix.
                stream.getTracks().forEach(track => track.stop());

                const mimeType = mediaRecorder.mimeType || 'audio/webm';
                const audioBlob = new Blob(audioChunks, { type: mimeType });

                const reader = new FileReader();
                reader.readAsDataURL(audioBlob);
                reader.onloadend = async () => {
                    const base64Audio = reader.result.split(',')[1];
                    const messageId = `voice-${Date.now()}`;
                    const messageToSend = {
                        type: 'voice-message',
                        chunk: base64Audio,
                        mimeType: mimeType, 
                        id: messageId,
                        replyTo: currentReplyTo
                    };
                    if (await sendPacket(messageToSend)) {
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audioPlayer = `<div class="voice-message-player"><audio controls src="${audioUrl}"></audio></div>`;
                        log(audioPlayer, 'sent', messageId, currentReplyTo);
                        cancelReply();
                    }
                };
            });

            mediaRecorder.start();
            recordButton.classList.add('recording');
            recordingIndicator.style.display = 'flex';
            let seconds = 0;
            recordingTimer.textContent = '00:00';
            recordingTimerInterval = setInterval(() => {
                seconds++;
                const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                const sec = (seconds % 60).toString().padStart(2, '0');
                recordingTimer.textContent = `${min}:${sec}`;
            }, 1000);

        } catch (err) {
            console.error("Error accessing microphone:", err);
            log('Microphone access denied. Please allow microphone permissions in your browser.', 'system');
        }
    }

    // MODIFICATION: Simplified stopRecording as logic is now in the 'stop' event listener.
    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
        }
        recordButton.classList.remove('recording');
        recordingIndicator.style.display = 'none';
        clearInterval(recordingTimerInterval);
    }

    recordButton.addEventListener('mousedown', startRecording);
    recordButton.addEventListener('mouseup', stopRecording);
    recordButton.addEventListener('touchstart', startRecording, { passive: true });
    recordButton.addEventListener('touchend', stopRecording);


    document.getElementById('cancelFileBtn').onclick = () => {
        if (sendingFile.id || receivingFile.id || fileSendQueue.length > 0) {
            cancelFileTransfer(true);
        } else if (sendingImageSticker.id || receivingImageSticker.id) {
            cancelImageStickerTransfer(true);
        }
    };
    
    async function enumerateCameras() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableCameras = devices.filter(device => device.kind === 'videoinput');
            console.log('Available cameras:', availableCameras);
            updateVideoCallButtonsState();
        } catch (error) {
            console.error('Error enumerating devices:', error);
            log('Could not access camera devices info.', 'system');
        }
    }


    document.addEventListener('DOMContentLoaded', async () => {
        document.body.classList.add('light');
        currentThemeIndex = 0;

        const savedChatBackground = localStorage.getItem('chatBackground');
        if (savedChatBackground) {
            applyChatBackground(savedChatBackground);
        }

        loadCustomStickers();
        renderStickerPickerContent();
        
        logToSetup('Enter a shared secret to begin.');
        updatePeerStatus('Offline', false);
        
        await enumerateCameras();
        navigator.mediaDevices.ondevicechange = enumerateCameras;

        updateVideoCallButtonsState();
    });

  </script>
</body>
</html>
